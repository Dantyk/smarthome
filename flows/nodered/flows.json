[
  {
    "id": "tab_loader",
    "type": "tab",
    "label": "Loader: modes.yaml",
    "disabled": false,
    "info": "Naƒç√≠tanie config/modes.yaml pri ≈°tarte\nValid√°cia sch√©my\nLog prefix: [modes]"
  },
  {
    "id": "tab_resolver",
    "type": "tab",
    "label": "Resolver: Active Modes",
    "disabled": false,
    "info": "Vyhodnot√≠ aktiv√°ciu modes podƒæa dow, tod, date_range, holiday, calendar_tag\nVr√°ti {room: regimeName} na z√°klade najvy≈°≈°ej priority\nLog prefix: [resolver]"
  },
  {
    "id": "tab_planner",
    "type": "tab",
    "label": "Planner: Edge-Based Scheduling",
    "disabled": false,
    "info": "Subflow: vstup {room, edges:[{at,value}]}\nCron-plus scheduling\nPublish: virt/room/<room>/target_temp + cmd/hvac/<room>/setpoint"
  },
  {
    "id": "tab_alerts",
    "type": "tab",
    "label": "Alerts: Router & Decision Matrix",
    "disabled": false,
    "info": "Input topics: event/safety/smoke/*, event/security/motion/*, meta/service/*/online\nDecision matrix: push/emergency/SMS/siren\nIntegration: Apprise"
  },
  {
    "id": "tab_health",
    "type": "tab",
    "label": "Health: Service Pinger",
    "disabled": false,
    "info": "HTTP ping slu≈æieb: mosquitto, baikal, nodered, z2m, zwavejsui, apprise\nPublish: meta/service/<name>/online (heartbeat)\nVersion info (retained)"
  },
  {
    "id": "tab_api",
    "type": "tab",
    "label": "API: Appsmith Endpoints",
    "disabled": false,
    "info": "REST API for Appsmith UI\nGET /api/status, GET/POST /api/mode\nPOST /api/override, GET /api/events/upcoming\nPOST /api/alerts/ack"
  },
  {
    "id": "tab_weather",
    "type": "tab",
    "label": "Weather",
    "disabled": false,
    "info": "OpenWeatherMap integration\nFetches current weather + 5-day forecast\nPublishes to virt/weather/current and virt/weather/forecast"
  },
  {
    "id": "tab_dashboard",
    "type": "tab",
    "label": "Dashboard",
    "disabled": false,
    "info": "Node-RED Dashboard UI\nWeather widget, Status cards, Controls"
  },
  {
    "id": "tab_holidays",
    "type": "tab",
    "label": "Holidays",
    "disabled": false,
    "info": "Holiday detection system\nSupports static fixed dates and moveable holidays (Easter)\nProvides isHoliday(date) function for resolver"
  },
  {
    "id": "tab_humidity",
    "type": "tab",
    "label": "Humidity Control",
    "disabled": false,
    "info": "Bathroom fan automation based on humidity\nHysteresis control: threshold_on 70%, threshold_off 60%\nManual override detection and cooldown logic"
  },
  {
    "id": "tab_seed",
    "type": "tab",
    "label": "Defaults Seeder",
    "disabled": false
  },
  {
    "id": "tab_override_expiry",
    "type": "tab",
    "label": "Override: Expiry Enforcement",
    "disabled": false
  },
  {
    "id": "tab_retain_diag",
    "type": "tab",
    "label": "Diagnostics: Retain Coverage",
    "disabled": false
  },
  {
    "id": "tab_ui_health",
    "type": "tab",
    "label": "Health: UI Heartbeat",
    "disabled": false
  },
  {
    "id": "3c9175e0418cb802",
    "type": "tab",
    "label": "Calendar: Baikal Delta-Sync",
    "disabled": false,
    "info": "CalDAV delta synchronization\nPolling interval: 20s\nDSL parsing: SMH MODE=, SMH BOOST, SMH OFFSET\nLate-add logic"
  },
  {
    "id": "33bedd3c7b4b855f",
    "type": "tab",
    "label": "Override Confirm",
    "disabled": false
  },
  {
    "id": "tab_calendar_google",
    "type": "tab",
    "label": "Calendar: Google Sync",
    "disabled": false,
    "info": "Google Calendar REST sync\nPolling interval: 60s\nMerges with Baikal events; preserves google source; DSL parsing identical"
  },
  {
    "id": "tab_calendar_health_ttl",
    "type": "tab",
    "label": "Health: Calendar Sources & TTL",
    "disabled": false,
    "info": "Health-check pre Google Calendar REST a TTL watchdog pre virt/calendar/events/current.\nPublikuje: meta/service/google_calendar/online (false pri chybe), meta/service/google_calendar/last_seen (retained).\nTTL: meta/service/calendar/online (true/false), virt/calendar/events/stale (retained)."
  },
  {
    "id": "tab_boost",
    "type": "tab",
    "label": "Boost: Management",
    "disabled": false,
    "info": "Boost timer countdown & state management\nSubscribes to virt/boost/+/minutes and virt/boost/+/target_temp\nDecrements timer every minute\nClears boost when timer reaches 0"
  },
  {
    "id": "tab_init_defaults",
    "type": "tab",
    "label": "Init: Default Values",
    "disabled": false,
    "info": "Publikuje default hodnoty pre MQTT topics pri ≈°tarte, ak neexistuj√∫ retained values"
  },
  {
    "id": "influx_test_flow",
    "type": "tab",
    "label": "InfluxDB Test",
    "disabled": false,
    "info": "Testovac√≠ flow pre overenie InfluxDB z√°pisu"
  },
  {
    "id": "planner_subflow",
    "type": "subflow",
    "name": "Planner Engine",
    "info": "Input: {room: string, edges: [{at: 'HH:MM', value: number}]}\nOutput: MQTT virt/room/{room}/target_temp + cmd/hvac/{room}/setpoint",
    "category": "SmartHome",
    "in": [
      {
        "x": 60,
        "y": 80,
        "wires": [
          {
            "id": "planner_sub_process"
          }
        ]
      }
    ],
    "out": [
      {
        "x": 700,
        "y": 80,
        "wires": [
          {
            "id": "planner_sub_mqtt",
            "port": 0
          }
        ]
      }
    ],
    "env": [],
    "meta": {},
    "color": "#DDAA99"
  },
  {
    "id": "weather_correlation_subflow",
    "type": "subflow",
    "name": "Weather Correlation",
    "info": "Input: {room: string, regimeTarget: number}\nOutput: {room: string, targetTemp: number (correlated)}",
    "category": "SmartHome",
    "in": [
      {
        "x": 60,
        "y": 80,
        "wires": [
          {
            "id": "weather_corr_function"
          }
        ]
      }
    ],
    "out": [
      {
        "x": 600,
        "y": 80,
        "wires": [
          {
            "id": "weather_corr_function",
            "port": 0
          }
        ]
      }
    ],
    "env": [],
    "meta": {},
    "color": "#87A980"
  },
  {
    "id": "mqtt_broker",
    "type": "mqtt-broker",
    "name": "Mosquitto",
    "broker": "mosquitto",
    "port": "1883",
    "clientid": "",
    "autoConnect": true,
    "usetls": false,
    "protocolVersion": "4",
    "keepalive": "60",
    "cleansession": true,
    "autoUnsubscribe": true,
    "birthTopic": "meta/service/nodered/online",
    "birthQos": "0",
    "birthRetain": "false",
    "birthPayload": "true",
    "birthMsg": {},
    "closeTopic": "meta/service/nodered/online",
    "closeQos": "0",
    "closeRetain": "false",
    "closePayload": "false",
    "closeMsg": {},
    "willTopic": "meta/service/nodered/online",
    "willQos": "0",
    "willRetain": "false",
    "willPayload": "false",
    "willMsg": {},
    "userProps": "",
    "sessionExpiry": ""
  },
  {
    "id": "main_tab",
    "type": "ui_tab",
    "name": "SmartHome",
    "icon": "dashboard",
    "order": 1,
    "disabled": false,
    "hidden": false
  },
  {
    "id": "weather_group",
    "type": "ui_group",
    "name": "Poƒçasie",
    "tab": "main_tab",
    "order": 1,
    "disp": true,
    "width": "6",
    "collapse": false
  },
  {
    "id": "0dec61823faa8800",
    "type": "ui_base",
    "theme": {
      "name": "theme-light",
      "lightTheme": {
        "default": "#0094CE",
        "baseColor": "#0094CE",
        "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif",
        "edited": false
      },
      "darkTheme": {
        "default": "#097479",
        "baseColor": "#097479",
        "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif",
        "edited": false
      },
      "customTheme": {
        "name": "Untitled Theme 1",
        "default": "#4B7930",
        "baseColor": "#4B7930",
        "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"
      },
      "themeState": {
        "base-color": {
          "default": "#0094CE",
          "value": "#0094CE",
          "edited": false
        },
        "page-titlebar-backgroundColor": {
          "value": "#0094CE",
          "edited": false
        },
        "page-backgroundColor": {
          "value": "#fafafa",
          "edited": false
        },
        "page-sidebar-backgroundColor": {
          "value": "#ffffff",
          "edited": false
        },
        "group-textColor": {
          "value": "#1bbfff",
          "edited": false
        },
        "group-borderColor": {
          "value": "#ffffff",
          "edited": false
        },
        "group-backgroundColor": {
          "value": "#ffffff",
          "edited": false
        },
        "widget-textColor": {
          "value": "#111111",
          "edited": false
        },
        "widget-backgroundColor": {
          "value": "#0094ce",
          "edited": false
        },
        "widget-borderColor": {
          "value": "#ffffff",
          "edited": false
        },
        "base-font": {
          "value": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"
        }
      },
      "angularTheme": {
        "primary": "indigo",
        "accents": "blue",
        "warn": "red",
        "background": "grey",
        "palette": "light"
      }
    },
    "site": {
      "name": "Node-RED Dashboard",
      "hideToolbar": "false",
      "allowSwipe": "false",
      "lockMenu": "false",
      "allowTempTheme": "true",
      "dateFormat": "DD/MM/YYYY",
      "sizes": {
        "sx": 48,
        "sy": 48,
        "gx": 6,
        "gy": 6,
        "cx": 6,
        "cy": 6,
        "px": 0,
        "py": 0
      }
    }
  },
  {
    "id": "81faacfd71aafa3e",
    "type": "influxdb",
    "hostname": "influxdb",
    "port": 8086,
    "protocol": "http",
    "database": "database",
    "name": "InfluxDB",
    "usetls": false,
    "tls": "",
    "influxdbVersion": "2.0",
    "url": "http://influxdb:8086",
    "timeout": 10,
    "rejectUnauthorized": true
  },
  {
    "id": "planner_sub_process",
    "type": "function",
    "z": "planner_subflow",
    "name": "Generate Cron Jobs",
    "func": "const room = msg.payload.room;\nconst edges = msg.payload.edges || [];\n\nif (!room || edges.length === 0) {\n    node.error('[planner] Invalid input: missing room or edges');\n    return null;\n}\n\n// Store edges in flow context\nconst existingJobs = flow.get(`planner_jobs_${room}`) || [];\n\n// Remove old cron jobs\nexistingJobs.forEach(jobId => {\n    // Send remove command to cron-plus\n    node.send({\n        topic: 'remove',\n        payload: jobId\n    });\n});\n\n// Create new cron jobs for each edge\nconst newJobs = [];\nedges.forEach((edge, idx) => {\n    const [hour, minute] = edge.at.split(':').map(Number);\n    const jobId = `${room}_edge_${idx}`;\n    \n    // Cron expression: \"second minute hour * * *\"\n    const cronExpr = `0 ${minute} ${hour} * * *`;\n    \n    newJobs.push({\n        name: jobId,\n        expression: cronExpr,\n        expressionType: 'cron',\n        payload: {\n            room: room,\n            value: edge.value,\n            edge: edge\n        },\n        payloadType: 'json',\n        topic: `planner/${room}/trigger`\n    });\n});\n\nflow.set(`planner_jobs_${room}`, newJobs.map(j => j.name));\nflow.set(`planner_edges_${room}`, edges);\n\nnode.warn(`[planner] Scheduled ${edges.length} edges for ${room}`);\n\nmsg.payload = {\n    room: room,\n    jobs: newJobs\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 230,
    "y": 80,
    "wires": [
      [
        "planner_sub_trigger"
      ]
    ]
  },
  {
    "id": "planner_sub_trigger",
    "type": "function",
    "z": "planner_subflow",
    "name": "Calculate Target Temp",
    "func": "const room = msg.payload.room;\nconst value = msg.payload.value;\n\n// Get current state\nconst modes = global.get('modes');\nconst calendarEvents = global.get('calendarEvents') || [];\nconst boost = flow.get(`boost_${room}_active`) || false;\nconst offset = flow.get(`offset_${room}_value`) || 0;\n\n// Priority: override > event > base\nlet targetTemp = value; // base from edge\n\n// Apply calendar event adjustments\nconst activeEvents = calendarEvents.filter(e => e.active);\nactiveEvents.forEach(event => {\n    if (event.type === 'offset' && event.params.room === room) {\n        targetTemp += event.params.offset;\n    }\n});\n\n// Apply boost override\nif (boost) {\n    const boostTemp = flow.get(`boost_${room}_target_temp`);\n    if (boostTemp) {\n        targetTemp = boostTemp;\n    }\n}\n\n// Apply global offset\ntargetTemp += offset;\n\n// Bounds checking\nconst minTemp = modes?.settings?.temp_min || 16;\nconst maxTemp = modes?.settings?.temp_max || 26;\ntargetTemp = Math.max(minTemp, Math.min(maxTemp, targetTemp));\n\nnode.warn(`[planner] ${room}: target=${targetTemp}¬∞C (base=${value}, offset=${offset}, boost=${boost})`);\n\nmsg.payload = targetTemp;\nmsg.room = room;\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 470,
    "y": 80,
    "wires": [
      [
        "planner_sub_mqtt"
      ]
    ]
  },
  {
    "id": "planner_sub_mqtt",
    "type": "function",
    "z": "planner_subflow",
    "name": "Publish MQTT",
    "func": "const room = msg.room;\nconst targetTemp = msg.payload;\n\nreturn [\n    {\n        topic: `virt/room/${room}/target_temp`,\n        payload: targetTemp,\n        retain: true\n    },\n    {\n        topic: `cmd/hvac/${room}/setpoint`,\n        payload: targetTemp,\n        retain: false\n    }\n];",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 680,
    "y": 80,
    "wires": [
      []
    ]
  },
  {
    "id": "weather_corr_function",
    "type": "function",
    "z": "weather_correlation_subflow",
    "name": "Calculate Correlation Œî",
    "func": "const cfg = global.get('modesCfg');\nconst weatherData = global.get('weatherCurrent');\nconst room = msg.payload.room;\nconst regimeTarget = msg.payload.regimeTarget;\n\nif (!cfg || !cfg.weather || !cfg.weather.correlation) {\n    node.error('[weather] Correlation not configured');\n    msg.payload.targetTemp = regimeTarget;\n    return msg;\n}\n\nconst corrCfg = cfg.weather.correlation;\n\nif (!corrCfg.enabled) {\n    msg.payload.targetTemp = regimeTarget;\n    return msg;\n}\n\nif (!weatherData) {\n    node.warn('[weather] Weather data not available for correlation');\n    msg.payload.targetTemp = regimeTarget;\n    return msg;\n}\n\nconst roomCfg = corrCfg.rooms[room];\n\nif (!roomCfg) {\n    node.warn(`[weather] No correlation config for ${room}`);\n    msg.payload.targetTemp = regimeTarget;\n    return msg;\n}\n\n// Check if override/BOOST is active (skip correlation)\nconst override = flow.get(`override_${room}`);\nif (override && override.active) {\n    node.warn(`[weather] Skipping correlation for ${room} (override active)`);\n    msg.payload.targetTemp = regimeTarget;\n    return msg;\n}\n\n// Calculate Œî = kT*(pivot-T) + kW*W + kD*dir_weights[octant]\nconst T = weatherData.temp_c;\nconst W = weatherData.wind_speed_ms;\nconst octant = weatherData.octant;\nconst pivot = roomCfg.pivot_temp_c !== undefined ? roomCfg.pivot_temp_c : corrCfg.default_pivot_temp_c;\nconst kT = roomCfg.kT;\nconst kW = roomCfg.kW;\nconst kD = roomCfg.kD;\nconst dirWeights = roomCfg.dir_weights || {};\nconst dirWeight = dirWeights[octant] || 0;\n\nconst deltaT = kT * (pivot - T);\nconst deltaW = kW * W;\nconst deltaD = kD * dirWeight;\n\nlet delta = deltaT + deltaW + deltaD;\n\n// Clamp delta\ndelta = Math.max(corrCfg.min_offset, Math.min(corrCfg.max_offset, delta));\n\nlet targetTemp = regimeTarget + delta;\n\n// Clamp to room limits\nconst roomLimits = cfg.limits.by_room[room] || cfg.limits.default;\ntargetTemp = Math.max(roomLimits.min, Math.min(roomLimits.max, targetTemp));\n\nnode.warn(`[weather] ${room}: ${regimeTarget}¬∞C + Œî${delta.toFixed(2)}¬∞C = ${targetTemp.toFixed(1)}¬∞C (T=${T}¬∞C, W=${W}m/s, ${octant})`);\n\nmsg.payload.targetTemp = Math.round(targetTemp * 10) / 10;\nmsg.payload.delta = Math.round(delta * 100) / 100;\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 300,
    "y": 80,
    "wires": [
      []
    ]
  },
  {
    "id": "loader_inject",
    "type": "inject",
    "z": "tab_loader",
    "name": "Startup",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": "5",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 120,
    "y": 100,
    "wires": [
      [
        "loader_schema_in"
      ]
    ]
  },
  {
    "id": "loader_schema_in",
    "type": "file in",
    "z": "tab_loader",
    "name": "Load Schema",
    "filename": "/config/modes.schema.json",
    "filenameType": "str",
    "format": "utf8",
    "chunk": false,
    "sendError": true,
    "encoding": "none",
    "allProps": false,
    "x": 290,
    "y": 100,
    "wires": [
      [
        "loader_schema_parse"
      ]
    ]
  },
  {
    "id": "loader_schema_parse",
    "type": "function",
    "z": "tab_loader",
    "name": "Parse Schema JSON",
    "func": "msg.schema = JSON.parse(msg.payload);\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 480,
    "y": 100,
    "wires": [
      [
        "loader_file_in"
      ]
    ]
  },
  {
    "id": "loader_file_in",
    "type": "file in",
    "z": "tab_loader",
    "name": "Read modes.yaml",
    "filename": "/config/modes.yaml",
    "filenameType": "str",
    "format": "utf8",
    "chunk": false,
    "sendError": true,
    "encoding": "none",
    "allProps": false,
    "x": 730,
    "y": 100,
    "wires": [
      [
        "loader_parse_yaml"
      ]
    ]
  },
  {
    "id": "loader_parse_yaml",
    "type": "function",
    "z": "tab_loader",
    "name": "Parse & Validate",
    "func": "// Parse YAML using js-yaml library\ntry {\n    const cfg = yaml.load(msg.payload);\n    \n    // Validate version\n    if (cfg.version !== 3) {\n        throw new Error(`Invalid version: ${cfg.version}, expected 3`);\n    }\n    \n    // Get schema from msg (loaded by previous node)\n    const schema = msg.schema;\n    \n    if (!schema) {\n        throw new Error('Schema not loaded');\n    }\n    \n    // Validate with ajv\n    const Ajv = ajv.default || ajv;\n    const ajvInstance = new Ajv();\n    const validate = ajvInstance.compile(schema);\n    const valid = validate(cfg);\n    \n    if (!valid) {\n        const errors = validate.errors.map(e => `${e.instancePath} ${e.message}`).join(', ');\n        throw new Error(`Schema validation failed: ${errors}`);\n    }\n    \n    // Expand groups -> rooms in modes\n    Object.keys(cfg.modes).forEach(modeName => {\n        const mode = cfg.modes[modeName];\n        const expandedRegimes = {};\n        \n        Object.keys(mode.room_regime).forEach(key => {\n            if (key === '*') {\n                // Expand * to all rooms\n                cfg.rooms.forEach(room => {\n                    expandedRegimes[room] = mode.room_regime[key];\n                });\n            } else if (cfg.groups && cfg.groups[key]) {\n                // Expand group to rooms\n                cfg.groups[key].forEach(room => {\n                    expandedRegimes[room] = mode.room_regime[key];\n                });\n            } else {\n                // Direct room assignment\n                expandedRegimes[key] = mode.room_regime[key];\n            }\n        });\n        \n        mode.room_regime = expandedRegimes;\n    });\n    \n    // Normalize dow (expand mon-fri, sat-sun, all)\n    const expandDow = (dowList) => {\n        if (!dowList) return [];\n        const expanded = new Set();\n        const allDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];\n        const weekdays = ['mon', 'tue', 'wed', 'thu', 'fri'];\n        const weekend = ['sat', 'sun'];\n        \n        dowList.forEach(dow => {\n            if (dow === 'all') allDays.forEach(d => expanded.add(d));\n            else if (dow === 'mon-fri') weekdays.forEach(d => expanded.add(d));\n            else if (dow === 'sat-sun') weekend.forEach(d => expanded.add(d));\n            else expanded.add(dow);\n        });\n        \n        return Array.from(expanded);\n    };\n    \n    Object.keys(cfg.modes).forEach(modeName => {\n        const mode = cfg.modes[modeName];\n        if (mode.activation.dow) {\n            mode.activation.dow = expandDow(mode.activation.dow);\n        }\n    });\n    \n    // Store in global context\n    global.set('modesCfg', cfg);\n    \n    node.status({fill: \"green\", shape: \"dot\", text: `v${cfg.version} loaded`});\n    node.warn(`[modes] Configuration v${cfg.version} loaded: ${cfg.rooms.length} rooms, ${Object.keys(cfg.modes).length} modes`);\n    \n    msg.payload = {\n        status: 'success',\n        version: cfg.version,\n        rooms: cfg.rooms,\n        modes: Object.keys(cfg.modes),\n        timestamp: new Date().toISOString()\n    };\n    \n    return msg;\n    \n} catch (error) {\n    node.status({fill: \"red\", shape: \"dot\", text: \"error\"});\n    node.error(\"[modes] Failed to load configuration: \" + error.message);\n    msg.payload = {\n        status: 'error',\n        error: error.message\n    };\n    return msg;\n}",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [
      {
        "var": "yaml",
        "module": "js-yaml"
      },
      {
        "var": "ajv",
        "module": "ajv"
      }
    ],
    "x": 960,
    "y": 100,
    "wires": [
      [
        "loader_mqtt_out"
      ]
    ]
  },
  {
    "id": "loader_mqtt_out",
    "type": "mqtt out",
    "z": "tab_loader",
    "name": "Config Status",
    "topic": "virt/system/config_loaded",
    "qos": "1",
    "retain": "true",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 1120,
    "y": 100,
    "wires": []
  },
  {
    "id": "resolver_startup",
    "type": "inject",
    "z": "tab_resolver",
    "name": "Startup",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": "15",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 100,
    "y": 60,
    "wires": [
      [
        "resolver_mqtt_trigger"
      ]
    ]
  },
  {
    "id": "resolver_periodic",
    "type": "inject",
    "z": "tab_resolver",
    "name": "Every 15min + Midnight",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "0,15,30,45 * * * *",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 100,
    "y": 20,
    "wires": [
      [
        "resolver_mqtt_trigger"
      ]
    ]
  },
  {
    "id": "resolver_mqtt_trigger",
    "type": "mqtt out",
    "z": "tab_resolver",
    "name": "",
    "topic": "internal/resolver/trigger",
    "qos": "1",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 300,
    "y": 60,
    "wires": []
  },
  {
    "id": "resolver_trigger_in",
    "type": "mqtt in",
    "z": "tab_resolver",
    "name": "Trigger",
    "topic": "internal/resolver/trigger",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 100,
    "y": 100,
    "wires": [
      [
        "resolver_function"
      ]
    ]
  },
  {
    "id": "resolver_function",
    "type": "function",
    "z": "tab_resolver",
    "name": "Resolve Active Modes",
    "func": "// Load config from global context\nconst cfg = global.get('modesCfg');\n\nnode.warn(`[resolver] Triggered! cfg=${!!cfg}, modes=${cfg ? Object.keys(cfg.modes||{}).join(',') : 'none'}`);\n\nif (!cfg || !cfg.modes) {\n    node.error('[resolver] Configuration not loaded');\n    return null;\n}\n\nconst now = new Date();\nconst dayNames = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\nconst currentDow = dayNames[now.getDay()];\nconst currentHour = now.getHours();\nconst currentMinute = now.getMinutes();\nconst currentTime = currentHour * 60 + currentMinute;\n\n// Get calendar events tags\nconst calendarEvents = global.get('calendarEvents') || [];\nconst activeCalendarTags = new Set();\ncalendarEvents.forEach(event => {\n    if (event.active && event.type === 'calendar') {\n        // Extract tags from CATEGORIES or SUMMARY\n        const summary = event.summary || '';\n        const matches = summary.match(/\\b(DOVOLENKA|HOME_OFFICE|DETI_DOMA)\\b/gi);\n        if (matches) {\n            matches.forEach(tag => activeCalendarTags.add(tag.toUpperCase()));\n        }\n    }\n});\n\n// Get holiday status from holidays tab\nconst isHoliday = global.get('todayIsHoliday') || false;\n\n// Evaluate each mode\nconst activeModesPerRoom = {};\n\nObject.keys(cfg.modes).forEach(modeName => {\n    const mode = cfg.modes[modeName];\n    const activation = mode.activation;\n    let isActive = true;\n    \n    if (modeName === 'hosty') {\n        node.warn(`[resolver] Processing hosty mode: activation=${JSON.stringify(activation)}`);\n    }\n    \n    // Check dow\n    if (activation.dow && activation.dow.length > 0) {\n        if (!activation.dow.includes(currentDow)) {\n            isActive = false;\n        }\n    }\n    \n    // Check tod (time of day)\n    if (isActive && activation.tod && activation.tod.length > 0) {\n        let inTodRange = false;\n        activation.tod.forEach(range => {\n            const [start, end] = range.split('-');\n            const [startH, startM] = start.split(':').map(Number);\n            const [endH, endM] = end.split(':').map(Number);\n            const startTime = startH * 60 + startM;\n            const endTime = endH * 60 + endM;\n            \n            if (currentTime >= startTime && currentTime <= endTime) {\n                inTodRange = true;\n            }\n        });\n        if (!inTodRange) {\n            isActive = false;\n        }\n    }\n    \n    // Check date_range\n    if (isActive && activation.date_range) {\n        const fromStr = activation.date_range.from; // MM-DD\n        const toStr = activation.date_range.to;\n        const [fromMonth, fromDay] = fromStr.split('-').map(Number);\n        const [toMonth, toDay] = toStr.split('-').map(Number);\n        \n        const currentMonth = now.getMonth() + 1;\n        const currentDay = now.getDate();\n        \n        // Simple range check (doesn't handle year wraparound)\n        const current = currentMonth * 100 + currentDay;\n        const from = fromMonth * 100 + fromDay;\n        const to = toMonth * 100 + toDay;\n        \n        if (from <= to) {\n            if (!(current >= from && current <= to)) {\n                isActive = false;\n            }\n        } else {\n            // Year wraparound (e.g., 12-24 to 01-06)\n            if (!(current >= from || current <= to)) {\n                isActive = false;\n            }\n        }\n    }\n    \n    // Check holiday\n    if (isActive && activation.holiday !== undefined) {\n        if (activation.holiday !== isHoliday) {\n            isActive = false;\n        }\n    }\n    \n    // Check calendar_tag\n    if (isActive && activation.calendar_tag) {\n        if (!activeCalendarTags.has(activation.calendar_tag)) {\n            isActive = false;\n        }\n    }\n    \n    // Check calendar_mode (for SMH MODE=xxx events)\n    if (isActive && activation.calendar_mode) {\n        const calendarModeEvents = calendarEvents.filter(e => \n            e.active && e.type === 'mode' && e.params.mode === activation.calendar_mode\n        );\n        node.warn(`[resolver] Mode ${modeName}: checking calendar_mode=${activation.calendar_mode}, found ${calendarModeEvents.length} active events`);\n        if (calendarModeEvents.length === 0) {\n            isActive = false;\n        }\n    }\n    \n    // If mode is active, add to rooms with priority\n    if (isActive) {\n        Object.keys(mode.room_regime).forEach(roomOrGroup => {\n            const regime = mode.room_regime[roomOrGroup];\n            \n            // Check if roomOrGroup is a group or single room\n            let targetRooms = [];\n            if (cfg.groups && cfg.groups[roomOrGroup]) {\n                // It's a group, expand to individual rooms\n                targetRooms = cfg.groups[roomOrGroup];\n            } else if (roomOrGroup === '*') {\n                // Wildcard for all rooms\n                targetRooms = cfg.rooms;\n            } else {\n                // Single room\n                targetRooms = [roomOrGroup];\n            }\n            \n            targetRooms.forEach(room => {\n                if (!activeModesPerRoom[room]) {\n                    activeModesPerRoom[room] = [];\n                }\n                \n                activeModesPerRoom[room].push({\n                    mode: modeName,\n                    regime: regime,\n                    priority: mode.priority\n                });\n            });\n        });\n    }\n});\n\n// Select highest priority regime for each room\nconst resolvedRegimes = {};\ncfg.rooms.forEach(room => {\n    const activeModes = activeModesPerRoom[room] || [];\n    \n    if (activeModes.length === 0) {\n        // No mode active, use base regime\n        resolvedRegimes[room] = cfg.base_regime_by_room[room] || 'PT';\n    } else {\n        // Sort by priority (highest first)\n        activeModes.sort((a, b) => b.priority - a.priority);\n        resolvedRegimes[room] = activeModes[0].regime;\n        \n        node.warn(`[resolver] ${room}: ${activeModes[0].mode} (priority ${activeModes[0].priority}) ‚Üí ${activeModes[0].regime}`);\n    }\n});\n\nnode.warn(`[resolver] Resolved regimes: ${JSON.stringify(resolvedRegimes)}`);\n\n// Determine dominant regime (most common regime across all rooms)\nconst regimeCounts = {};\nObject.values(resolvedRegimes).forEach(regime => {\n    regimeCounts[regime] = (regimeCounts[regime] || 0) + 1;\n});\n\nconst dominantRegime = Object.keys(regimeCounts).reduce((a, b) => \n    regimeCounts[a] > regimeCounts[b] ? a : b, 'PT'\n);\n\nnode.warn(`[resolver] Dominant regime: ${dominantRegime}`);\n\n// Store in global context\nglobal.set('activeRegimesByRoom', resolvedRegimes);\nglobal.set('activeMode', dominantRegime);\n\nmsg.payload = {\n    status: 'success',\n    regimes: resolvedRegimes,\n    timestamp: now.toISOString()\n};\n\nconst msgMode = {\n    payload: dominantRegime\n};\n\nreturn [msg, msgMode];",
    "outputs": 2,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 320,
    "y": 100,
    "wires": [
      [
        "resolver_mqtt_out",
        "resolver_trigger_planner"
      ],
      [
        "resolver_mode_mqtt_out"
      ]
    ]
  },
  {
    "id": "resolver_mqtt_out",
    "type": "mqtt out",
    "z": "tab_resolver",
    "name": "Active Regimes",
    "topic": "virt/system/active_regimes",
    "qos": "1",
    "retain": "true",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 570,
    "y": 80,
    "wires": []
  },
  {
    "id": "resolver_mode_mqtt_out",
    "type": "mqtt out",
    "z": "tab_resolver",
    "name": "Active Mode",
    "topic": "virt/system/active_mode",
    "qos": "1",
    "retain": "true",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 570,
    "y": 140,
    "wires": []
  },
  {
    "id": "resolver_trigger_planner",
    "type": "mqtt out",
    "z": "tab_resolver",
    "name": "Trigger Orchestrator",
    "topic": "internal/planner/orchestrate",
    "qos": "1",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 580,
    "y": 120,
    "wires": []
  },
  {
    "id": "planner_orchestrator_in",
    "type": "mqtt in",
    "z": "tab_planner",
    "name": "Orchestrator Trigger",
    "topic": "internal/planner/orchestrate",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 140,
    "y": 60,
    "wires": [
      [
        "planner_orchestrator_function"
      ]
    ]
  },
  {
    "id": "planner_orchestrator_startup",
    "type": "inject",
    "z": "tab_planner",
    "name": "Startup + Midnight",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "00 00 * * *",
    "once": true,
    "onceDelay": "10",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 160,
    "y": 20,
    "wires": [
      [
        "planner_orchestrator_mqtt_trigger"
      ]
    ]
  },
  {
    "id": "planner_orchestrator_mqtt_trigger",
    "type": "mqtt out",
    "z": "tab_planner",
    "name": "",
    "topic": "internal/planner/orchestrate",
    "qos": "1",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 400,
    "y": 20,
    "wires": []
  },
  {
    "id": "planner_orchestrator_function",
    "type": "function",
    "z": "tab_planner",
    "name": "Orchestrate All Rooms",
    "func": "// Load config and active regimes\nconst cfg = global.get('modesCfg');\nconst activeRegimes = global.get('activeRegimesByRoom') || {};\n\nif (!cfg || !cfg.temperature_regimes) {\n    node.error('[planner] Configuration not loaded');\n    return null;\n}\n\nconst now = new Date();\nconst dayNames = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\nconst currentDow = dayNames[now.getDay()];\n\nnode.warn(`[planner] Orchestrating schedules for all rooms (dow: ${currentDow})`);\n\nconst messages = [];\n\ncfg.rooms.forEach(room => {\n    const regimeName = activeRegimes[room] || cfg.base_regime_by_room[room] || 'PT';\n    const regime = cfg.temperature_regimes[regimeName];\n    \n    if (!regime || !regime.schedule) {\n        node.warn(`[planner] No schedule for regime ${regimeName}`);\n        return;\n    }\n    \n    // Find applicable schedule for current dow\n    let scheduleKey = null;\n    \n    if (regime.schedule[currentDow]) {\n        scheduleKey = currentDow;\n    } else if (regime.schedule['mon-fri'] && ['mon', 'tue', 'wed', 'thu', 'fri'].includes(currentDow)) {\n        scheduleKey = 'mon-fri';\n    } else if (regime.schedule['sat-sun'] && ['sat', 'sun'].includes(currentDow)) {\n        scheduleKey = 'sat-sun';\n    } else if (regime.schedule['all']) {\n        scheduleKey = 'all';\n    }\n    \n    if (!scheduleKey) {\n        node.warn(`[planner] No schedule key for ${room} on ${currentDow}`);\n        return;\n    }\n    \n    const schedule = regime.schedule[scheduleKey];\n    \n    // Convert schedule edges to planner format\n    const edges = [];\n    schedule.forEach(edge => {\n        // Expand groups and rooms\n        const temps = {};\n        \n        if (edge.set.groups) {\n            Object.keys(edge.set.groups).forEach(groupName => {\n                const groupRooms = cfg.groups[groupName] || [];\n                groupRooms.forEach(r => {\n                    temps[r] = edge.set.groups[groupName];\n                });\n            });\n        }\n        \n        if (edge.set.rooms) {\n            Object.keys(edge.set.rooms).forEach(r => {\n                temps[r] = edge.set.rooms[r];\n            });\n        }\n        \n        if (temps[room] !== undefined) {\n            edges.push({\n                at: edge.at,\n                value: temps[room]\n            });\n        }\n    });\n    \n    // Check if boost is active even if no edges\n    const boostActive = global.get(`boost_${room}_active`) || false;\n    node.warn(`[planner-debug] ${room}: edges=${edges.length}, boostActive=${boostActive}`);\n    \n    if (edges.length === 0 && !boostActive) {\n        node.warn(`[planner] No edges for ${room} in ${regimeName}`);\n        return;\n    }\n    \n    if (edges.length > 0) {\n        node.warn(`[planner] ${room}: ${regimeName} ‚Üí ${edges.length} edges`);\n    } else if (boostActive) {\n        node.warn(`[planner] ${room}: No edges but BOOST active, sending empty edges`);\n    }\n    \n    messages.push({\n        topic: `internal/planner/edges/${room}`,\n        payload: {\n            room: room,\n            regime: regimeName,\n            edges: edges\n        }\n    });\n});\n\nreturn [messages];",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 60,
    "wires": [
      [
        "planner_orchestrator_mqtt_out"
      ]
    ]
  },
  {
    "id": "planner_orchestrator_mqtt_out",
    "type": "mqtt out",
    "z": "tab_planner",
    "name": "",
    "topic": "",
    "qos": "1",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 630,
    "y": 60,
    "wires": []
  },
  {
    "id": "planner_edges_in",
    "type": "mqtt in",
    "z": "tab_planner",
    "name": "Edges Handler",
    "topic": "internal/planner/edges/#",
    "qos": "1",
    "datatype": "json",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 130,
    "y": 140,
    "wires": [
      [
        "planner_apply_weather_corr"
      ]
    ]
  },
  {
    "id": "planner_apply_weather_corr",
    "type": "function",
    "z": "tab_planner",
    "name": "Apply Weather Correlation to Edges",
    "func": "const cfg = global.get('modesCfg');\nconst weatherData = global.get('weatherCurrent');\nconst room = msg.payload.room;\nconst edges = msg.payload.edges || [];\n\nif (!cfg || !cfg.weather || !cfg.weather.correlation) {\n    node.warn('[planner] Weather correlation not configured, skipping');\n    msg.payload.correlatedEdges = edges;\n    return msg;\n}\n\nconst corrCfg = cfg.weather.correlation;\n\nif (!corrCfg.enabled || !weatherData) {\n    msg.payload.correlatedEdges = edges;\n    return msg;\n}\n\nconst roomCfg = corrCfg.rooms[room];\n\nif (!roomCfg) {\n    msg.payload.correlatedEdges = edges;\n    return msg;\n}\n\n// Check override\nconst override = flow.get(`override_${room}`);\nif (override && override.active) {\n    node.warn(`[planner] Skipping weather correlation for ${room} (override active)`);\n    msg.payload.correlatedEdges = edges;\n    return msg;\n}\n\n// Apply correlation to each edge\nconst T = weatherData.temp_c;\nconst W = weatherData.wind_speed_ms;\nconst octant = weatherData.octant;\nconst pivot = roomCfg.pivot_temp_c !== undefined ? roomCfg.pivot_temp_c : corrCfg.default_pivot_temp_c;\nconst kT = roomCfg.kT;\nconst kW = roomCfg.kW;\nconst kD = roomCfg.kD;\nconst dirWeights = roomCfg.dir_weights || {};\nconst dirWeight = dirWeights[octant] || 0;\n\nconst deltaT = kT * (pivot - T);\nconst deltaW = kW * W;\nconst deltaD = kD * dirWeight;\n\nlet delta = deltaT + deltaW + deltaD;\ndelta = Math.max(corrCfg.min_offset, Math.min(corrCfg.max_offset, delta));\n\nconst correlatedEdges = edges.map(edge => {\n    let targetTemp = edge.value + delta;\n    \n    // Clamp to room limits\n    const roomLimits = cfg.limits.by_room[room] || cfg.limits.default;\n    targetTemp = Math.max(roomLimits.min, Math.min(roomLimits.max, targetTemp));\n    targetTemp = Math.round(targetTemp * 10) / 10;\n    \n    return {\n        at: edge.at,\n        value: targetTemp,\n        originalValue: edge.value,\n        delta: Math.round(delta * 100) / 100\n    };\n});\n\nnode.warn(`[planner] ${room}: Applied Œî${delta.toFixed(2)}¬∞C (T=${T}¬∞C, W=${W}m/s, ${octant})`);\n\nmsg.payload.correlatedEdges = correlatedEdges;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 410,
    "y": 140,
    "wires": [
      [
        "planner_publish_targets"
      ]
    ]
  },
  {
    "id": "planner_publish_targets",
    "type": "function",
    "z": "tab_planner",
    "name": "Publish Target Temps",
    "func": "const room = msg.payload.room;\nconst edges = msg.payload.correlatedEdges || [];\n\n// CHECK BOOST OVERRIDE FIRST\nconst boostActive = global.get(`boost_${room}_active`) || false;\nconst boostTemp = global.get(`boost_${room}_target_temp`);\n\nif (boostActive && boostTemp) {\n    // Boost is active - publish ONLY boost temperature\n    node.warn(`[planner] ${room}: BOOST ACTIVE, publishing ${boostTemp}¬∞C (ignoring edges)`);\n    \n    return [[\n        {\n            topic: `virt/room/${room}/target_temp`,\n            payload: boostTemp,\n            retain: true\n        },\n        {\n            topic: `cmd/hvac/${room}/setpoint`,\n            payload: boostTemp,\n            retain: false\n        }\n    ]];\n}\n\n// No boost - proceed with normal edge-based schedule\nif (edges.length === 0) {\n    return null;\n}\n\nconst messages = [];\n\nedges.forEach(edge => {\n    messages.push({\n        topic: `virt/room/${room}/target_temp`,\n        payload: {\n            room: room,\n            at: edge.at,\n            value: edge.value,\n            originalValue: edge.originalValue,\n            delta: edge.delta,\n            timestamp: new Date().toISOString()\n        },\n        retain: true\n    });\n    \n    // Also publish to cmd/hvac for actual control\n    messages.push({\n        topic: `cmd/hvac/${room}/setpoint`,\n        payload: edge.value,\n        retain: false\n    });\n});\n\nnode.warn(`[planner] ${room}: Published ${edges.length} target temps`);\n\nreturn [messages];",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 690,
    "y": 140,
    "wires": [
      [
        "planner_mqtt_multi"
      ]
    ]
  },
  {
    "id": "planner_mqtt_multi",
    "type": "mqtt out",
    "z": "tab_planner",
    "name": "",
    "topic": "",
    "qos": "1",
    "retain": "",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 910,
    "y": 140,
    "wires": []
  },
  {
    "id": "alerts_smoke_in",
    "type": "mqtt in",
    "z": "tab_alerts",
    "name": "Smoke Detectors",
    "topic": "event/safety/smoke/+/trigger",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": false,
    "inputs": 0,
    "x": 140,
    "y": 80,
    "wires": [
      [
        "alerts_router"
      ]
    ]
  },
  {
    "id": "alerts_motion_in",
    "type": "mqtt in",
    "z": "tab_alerts",
    "name": "Motion Sensors",
    "topic": "event/security/motion/+/trigger",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": false,
    "inputs": 0,
    "x": 140,
    "y": 140,
    "wires": [
      [
        "alerts_router"
      ]
    ]
  },
  {
    "id": "alerts_service_in",
    "type": "mqtt in",
    "z": "tab_alerts",
    "name": "Service Health",
    "topic": "meta/service/+/online",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": false,
    "inputs": 0,
    "x": 140,
    "y": 200,
    "wires": [
      [
        "alerts_router"
      ]
    ]
  },
  {
    "id": "alerts_router",
    "type": "function",
    "z": "tab_alerts",
    "name": "Decision Matrix",
    "func": "const topic = msg.topic;\nconst payload = msg.payload;\n\n// Parse topic\nconst parts = topic.split('/');\nconst category = parts[1]; // safety, security, service\nconst type = parts[2];     // smoke, motion, mosquitto\nconst location = parts[3]; // living, entrance, etc.\n\nconst alert = {\n    category: category,\n    type: type,\n    location: location,\n    payload: payload,\n    timestamp: new Date().toISOString(),\n    severity: 'info',\n    actions: []\n};\n\n// Decision matrix\nif (category === 'safety') {\n    if (type === 'smoke') {\n        alert.severity = 'emergency';\n        alert.actions = ['pushover_emergency', 'sms', 'siren'];\n        alert.message = `üî• PO≈ΩIAR DETEKOVAN√ù: ${location}`;\n    }\n}\n\nif (category === 'security') {\n    if (type === 'motion') {\n        // Check if home is locked\n        const lockState = flow.get('lock_main_state') || false;\n        if (lockState) {\n            alert.severity = 'warning';\n            alert.actions = ['pushover'];\n            alert.message = `üö® Pohyb detekovan√Ω: ${location} (dom zamknut√Ω)`;\n        } else {\n            alert.severity = 'info';\n            alert.actions = [];\n            alert.message = `üëÅÔ∏è Pohyb: ${location}`;\n        }\n    }\n}\n\nif (category === 'service') {\n    const serviceName = type;\n    const isOnline = payload === true || payload === 'true' || payload === 1;\n    \n    if (!isOnline) {\n        alert.severity = 'warning';\n        alert.actions = ['pushover'];\n        alert.message = `‚ö†Ô∏è Slu≈æba offline: ${serviceName}`;\n    } else {\n        alert.severity = 'info';\n        alert.actions = [];\n        alert.message = `‚úÖ Slu≈æba online: ${serviceName}`;\n    }\n}\n\n// Store alert in history\nconst alertHistory = global.get('alertHistory') || [];\nalertHistory.unshift(alert);\nif (alertHistory.length > 100) alertHistory.pop();\nglobal.set('alertHistory', alertHistory);\n\nnode.warn(`[alerts] ${alert.severity}: ${alert.message}`);\n\nmsg.payload = alert;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 400,
    "y": 140,
    "wires": [
      [
        "alerts_switch"
      ]
    ]
  },
  {
    "id": "alerts_switch",
    "type": "switch",
    "z": "tab_alerts",
    "name": "By Severity",
    "property": "payload.severity",
    "propertyType": "msg",
    "rules": [
      {
        "t": "eq",
        "v": "emergency",
        "vt": "str"
      },
      {
        "t": "eq",
        "v": "warning",
        "vt": "str"
      },
      {
        "t": "eq",
        "v": "info",
        "vt": "str"
      }
    ],
    "checkall": "false",
    "repair": false,
    "outputs": 3,
    "x": 590,
    "y": 140,
    "wires": [
      [
        "alerts_emergency"
      ],
      [
        "alerts_warning"
      ],
      [
        "alerts_info"
      ]
    ]
  },
  {
    "id": "alerts_emergency",
    "type": "function",
    "z": "tab_alerts",
    "name": "Emergency Actions",
    "func": "const alert = msg.payload;\nconst messages = [];\n\nconst user = env.get('PUSHOVER_USER');\nconst token = env.get('PUSHOVER_TOKEN');\n\n// Pushover emergency (priority=2, retry, expire)\nif (alert.actions.includes('pushover_emergency')) {\n    messages.push({\n        topic: 'apprise/notify',\n        payload: {\n            urls: `pover://${user}@${token}`,\n            title: 'EMERGENCY',\n            body: alert.message,\n            priority: 2,\n            retry: 30,\n            expire: 3600\n        }\n    });\n}\n\n// SMS via Gammu\nif (alert.actions.includes('sms')) {\n    const mobil = global.get('modes')?.settings?.mobil || '+421903789694';\n    messages.push({\n        topic: 'sms/send',\n        payload: {\n            number: mobil,\n            text: alert.message\n        }\n    });\n}\n\n// Siren control\nif (alert.actions.includes('siren')) {\n    messages.push({\n        topic: 'cmd/siren/main/state',\n        payload: 'ON'\n    });\n}\n\nnode.warn(`[alerts] Emergency: ${alert.message}`);\n\nreturn [messages];",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 800,
    "y": 80,
    "wires": [
      [
        "alerts_mqtt_out"
      ]
    ]
  },
  {
    "id": "alerts_warning",
    "type": "function",
    "z": "tab_alerts",
    "name": "Warning Actions",
    "func": "const alert = msg.payload;\nconst messages = [];\n\nconst user = env.get('PUSHOVER_USER');\nconst token = env.get('PUSHOVER_TOKEN');\n\n// Standard Pushover notification\nif (alert.actions.includes('pushover')) {\n    messages.push({\n        topic: 'apprise/notify',\n        payload: {\n            urls: `pover://${user}@${token}`,\n            title: 'Warning',\n            body: alert.message,\n            priority: 1\n        }\n    });\n}\n\nnode.warn(`[alerts] Warning: ${alert.message}`);\n\nreturn [messages];",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 800,
    "y": 140,
    "wires": [
      [
        "alerts_mqtt_out"
      ]
    ]
  },
  {
    "id": "alerts_info",
    "type": "function",
    "z": "tab_alerts",
    "name": "Info (Log Only)",
    "func": "const alert = msg.payload;\n\n// Just log, no notifications\nnode.log(`[alerts] Info: ${alert.message}`);\n\nreturn null;",
    "outputs": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 800,
    "y": 200,
    "wires": []
  },
  {
    "id": "alerts_mqtt_out",
    "type": "mqtt out",
    "z": "tab_alerts",
    "name": "",
    "topic": "",
    "qos": "0",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 1010,
    "y": 110,
    "wires": []
  },
  {
    "id": "alerts_event_in",
    "type": "mqtt in",
    "z": "tab_alerts",
    "name": "Event Triggers",
    "topic": "event/#",
    "qos": "1",
    "datatype": "json",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": false,
    "rh": 0,
    "inputs": 0,
    "x": 110,
    "y": 100,
    "wires": [
      [
        "alerts_router"
      ]
    ]
  },
  {
    "id": "alerts_channel_split",
    "type": "function",
    "z": "tab_alerts",
    "name": "Split Channels",
    "func": "// Split message into multiple messages, one per channel per recipient\nconst cfg = global.get('modesCfg');\nif (!cfg || !cfg.notifications) return null;\n\nconst messages = [];\n\nmsg.channels.forEach(channel => {\n    msg.recipients.forEach(recipient => {\n        const contact = cfg.notifications.contacts[recipient];\n        if (!contact) {\n            node.warn(`[alerts] Unknown contact: ${recipient}`);\n            return;\n        }\n        \n        const channelCfg = cfg.notifications.channels[channel];\n        if (!channelCfg) {\n            node.warn(`[alerts] Unknown channel: ${channel}`);\n            return;\n        }\n        \n        messages.push({\n            topic: `internal/notify/${channel}`,\n            payload: {\n                channel: channel,\n                recipient: recipient,\n                contact: contact,\n                channelCfg: channelCfg,\n                routeKey: msg.routeKey,\n                location: msg.location,\n                severity: msg.severity,\n                message: `[${msg.severity.toUpperCase()}] ${msg.routeKey} at ${msg.location}`,\n                timestamp: msg.timestamp,\n                alertId: msg.alertId\n            }\n        });\n    });\n});\n\nreturn [messages];",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 520,
    "y": 100,
    "wires": [
      [
        "alerts_push_handler",
        "alerts_email_handler",
        "alerts_sms_handler"
      ]
    ]
  },
  {
    "id": "alerts_push_handler",
    "type": "function",
    "z": "tab_alerts",
    "name": "Push (Apprise)",
    "func": "if (msg.payload.channel !== 'push') return null;\n\nconst url = msg.payload.channelCfg.url_template.replace('{contact.push}', msg.payload.contact.push);\n\nnode.warn(`[alerts] Sending push to ${msg.payload.recipient}: ${msg.payload.message}`);\n\nmsg.url = url;\nmsg.method = 'POST';\nmsg.headers = {\n    'Content-Type': 'application/json'\n};\nmsg.payload = {\n    body: msg.payload.message,\n    title: 'SmartHome Alert'\n};\n\nreturn msg;",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 740,
    "y": 60,
    "wires": [
      [
        "alerts_http_request"
      ]
    ]
  },
  {
    "id": "alerts_email_handler",
    "type": "function",
    "z": "tab_alerts",
    "name": "Email (SMTP)",
    "func": "if (msg.payload.channel !== 'email') return null;\n\nconst channelCfg = msg.payload.channelCfg;\n\nnode.warn(`[alerts] Sending email to ${msg.payload.recipient}: ${msg.payload.message}`);\n\nmsg.topic = `SmartHome Alert: ${msg.payload.routeKey}`;\nmsg.payload = {\n    from: channelCfg.from,\n    to: msg.payload.contact.email,\n    subject: msg.topic,\n    text: `${msg.payload.message}\\n\\nLocation: ${msg.payload.location}\\nTimestamp: ${msg.payload.timestamp}`\n};\n\nmsg.smtpConfig = {\n    host: channelCfg.host,\n    port: channelCfg.port,\n    secure: channelCfg.tls || false,\n    auth: {\n        user: channelCfg.user,\n        pass: channelCfg.pass\n    }\n};\n\n// Note: Requires node-red-node-email\n// For now, just log (email node needs to be added separately)\nnode.log('[alerts] Email would be sent (node-red-node-email required)');\n\nreturn msg;",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 740,
    "y": 120,
    "wires": [
      []
    ]
  },
  {
    "id": "alerts_sms_handler",
    "type": "function",
    "z": "tab_alerts",
    "name": "SMS (Gammu)",
    "func": "if (msg.payload.channel !== 'sms') return null;\n\nconst url = msg.payload.channelCfg.url_template.replace('{contact.sms}', encodeURIComponent(msg.payload.contact.sms));\n\nnode.warn(`[alerts] Sending SMS to ${msg.payload.recipient}: ${msg.payload.message}`);\n\nmsg.url = url;\nmsg.method = 'POST';\nmsg.headers = {\n    'Content-Type': 'application/json'\n};\nmsg.payload = {\n    number: msg.payload.contact.sms,\n    text: msg.payload.message\n};\n\nreturn msg;",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 740,
    "y": 180,
    "wires": [
      [
        "alerts_http_request"
      ]
    ]
  },
  {
    "id": "alerts_http_request",
    "type": "http request",
    "z": "tab_alerts",
    "name": "Send Notification",
    "method": "use",
    "ret": "txt",
    "paytoqs": "ignore",
    "url": "",
    "tls": "",
    "persist": false,
    "proxy": "",
    "insecureHTTPParser": false,
    "authType": "",
    "senderr": false,
    "headers": [],
    "x": 970,
    "y": 120,
    "wires": [
      [
        "alerts_log_result"
      ]
    ]
  },
  {
    "id": "alerts_log_result",
    "type": "function",
    "z": "tab_alerts",
    "name": "Log Result",
    "func": "if (msg.statusCode === 200 || msg.statusCode === 201) {\n    node.log(`[alerts] Notification sent successfully (${msg.statusCode})`);\n} else {\n    node.warn(`[alerts] Notification failed: ${msg.statusCode} ${msg.payload}`);\n}\nreturn null;",
    "outputs": 0,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1180,
    "y": 120,
    "wires": []
  },
  {
    "id": "alerts_siren_out",
    "type": "mqtt out",
    "z": "tab_alerts",
    "name": "Siren Command",
    "topic": "",
    "qos": "1",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 530,
    "y": 160,
    "wires": []
  },
  {
    "id": "alerts_escalation_check",
    "type": "inject",
    "z": "tab_alerts",
    "name": "Check Escalations",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "30",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "{}",
    "payloadType": "json",
    "x": 140,
    "y": 260,
    "wires": [
      [
        "alerts_escalation_processor"
      ]
    ]
  },
  {
    "id": "alerts_escalation_processor",
    "type": "function",
    "z": "tab_alerts",
    "name": "Process Escalations",
    "func": "// Get all escalations from flow context\nconst flowKeys = flow.keys();\nconst now = Date.now();\nconst messages = [];\n\nflowKeys.forEach(key => {\n    if (!key.startsWith('escalation_')) return;\n    \n    const escalation = flow.get(key);\n    if (!escalation) return;\n    \n    // Check if escalation time has passed\n    if (now >= escalation.escalateAt) {\n        node.warn(`[alerts] Escalating ${escalation.message.alertId}`);\n        \n        // Send escalated notification\n        const escalatedMsg = Object.assign({}, escalation.message);\n        escalatedMsg.channels = escalation.escalateChannels;\n        escalatedMsg.escalated = true;\n        \n        messages.push(escalatedMsg);\n        \n        // Remove from flow context\n        flow.set(key, null);\n    }\n});\n\nif (messages.length > 0) {\n    node.log(`[alerts] Processing ${messages.length} escalations`);\n}\n\nreturn [messages];",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 370,
    "y": 260,
    "wires": [
      [
        "alerts_channel_split"
      ]
    ]
  },
  {
    "id": "health_cron",
    "type": "cronplus",
    "z": "tab_health",
    "name": "Every 2min + Startup",
    "outputField": "payload",
    "timeZone": "",
    "storeName": "",
    "commandResponseMsgOutput": "output1",
    "defaultLocation": "",
    "defaultLocationType": "default",
    "outputs": 1,
    "options": [
      {
        "name": "startup",
        "topic": "startup",
        "payloadType": "json",
        "payload": "[\"mosquitto\",\"baikal\",\"nodered\",\"zigbee2mqtt\",\"zwavejsui\",\"apprise\"]",
        "expressionType": "cron",
        "expression": "0 * * * * *",
        "location": "",
        "offset": "0",
        "solarType": "all",
        "solarEvents": "sunrise,sunset"
      },
      {
        "name": "ping",
        "topic": "ping",
        "payloadType": "json",
        "payload": "[\"mosquitto\",\"baikal\",\"nodered\",\"zigbee2mqtt\",\"zwavejsui\",\"apprise\"]",
        "expressionType": "cron",
        "expression": "0 */2 * * * *",
        "location": "",
        "offset": "0",
        "solarType": "all",
        "solarEvents": "sunrise,sunset"
      }
    ],
    "x": 170,
    "y": 100,
    "wires": [
      [
        "health_split"
      ]
    ]
  },
  {
    "id": "health_split",
    "type": "split",
    "z": "tab_health",
    "name": "Split Services",
    "splt": "\\n",
    "spltType": "str",
    "arraySplt": 1,
    "arraySpltType": "len",
    "stream": false,
    "addname": "",
    "x": 350,
    "y": 100,
    "wires": [
      [
        "health_prepare_url"
      ]
    ]
  },
  {
    "id": "health_prepare_url",
    "type": "function",
    "z": "tab_health",
    "name": "Prepare URL",
    "func": "const service = typeof msg.payload === 'string' ? msg.payload : msg.payload.toString();\nconst baikalUrl = env.get('BAIKAL_BASE_URL') || 'http://baikal:80';\n\nconst serviceUrls = {\n    'mosquitto': 'http://mosquitto:9001',\n    'baikal': baikalUrl,\n    'nodered': 'http://localhost:1880',\n    'zigbee2mqtt': 'http://zigbee2mqtt:8080',\n    'zwavejsui': 'http://zwavejsui:8091',\n    'apprise': 'http://apprise:8000'\n};\n\nconst url = serviceUrls[service];\n\nif (!url) {\n    node.error(`[health] Unknown service: ${service}`);\n    return null;\n}\n\nmsg.url = url;\nmsg.service = service;\n\n// Add Basic auth for Baikal\nif (service === 'baikal') {\n    const user = env.get('BAIKAL_USER') || 'smarthome';\n    const pass = env.get('BAIKAL_PASS') || 'smarthome';\n    const auth = Buffer.from(`${user}:${pass}`).toString('base64');\n    msg.headers = {\n        'Authorization': `Basic ${auth}`\n    };\n}\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 520,
    "y": 100,
    "wires": [
      [
        "health_http_request"
      ]
    ]
  },
  {
    "id": "health_http_request",
    "type": "http request",
    "z": "tab_health",
    "name": "HTTP Ping",
    "method": "GET",
    "ret": "txt",
    "paytoqs": "ignore",
    "url": "",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "x": 690,
    "y": 100,
    "wires": [
      [
        "health_process"
      ]
    ]
  },
  {
    "id": "health_process",
    "type": "function",
    "z": "tab_health",
    "name": "Process Response",
    "func": "const service = msg.service;\nconst statusCode = msg.statusCode;\nconst isOnline = statusCode >= 200 && statusCode < 400;\n\nnode.status({fill: isOnline ? \"green\" : \"red\", shape: \"dot\", text: service});\n\nmsg.payload = {\n    service: service,\n    online: isOnline,\n    statusCode: statusCode,\n    timestamp: new Date().toISOString()\n};\n\nnode.warn(`[health] ${service}: ${isOnline ? 'online' : 'offline'} (${statusCode})`);\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 860,
    "y": 100,
    "wires": [
      [
        "health_mqtt_out"
      ]
    ]
  },
  {
    "id": "health_mqtt_out",
    "type": "function",
    "z": "tab_health",
    "name": "Publish Health",
    "func": "const service = msg.payload.service;\nconst online = msg.payload.online;\n\nreturn [\n    {\n        topic: `meta/service/${service}/online`,\n        payload: online,\n        retain: false // TTL handled by expiry\n    },\n    {\n        topic: `meta/service/${service}/last_seen`,\n        payload: msg.payload.timestamp,\n        retain: true\n    }\n];",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 940,
    "y": 100,
    "wires": [
      [
        "health_mqtt_final"
      ]
    ]
  },
  {
    "id": "health_mqtt_final",
    "type": "mqtt out",
    "z": "tab_health",
    "name": "",
    "topic": "",
    "qos": "0",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 1130,
    "y": 100,
    "wires": []
  },
  {
    "id": "api_status_in",
    "type": "http in",
    "z": "tab_api",
    "name": "GET /api/status",
    "url": "/api/status",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 140,
    "y": 80,
    "wires": [
      [
        "api_status_handler"
      ]
    ]
  },
  {
    "id": "api_status_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Status Handler",
    "func": "const modes = global.get('modes') || {};\nconst modesCfg = global.get('modesCfg') || {};\nconst calendarEvents = global.get('calendarEvents') || [];\nconst alertHistory = global.get('alertHistory') || [];\nconst rooms = modesCfg.rooms || modes.rooms || [];\nconst roomStatus = [];\n\nrooms.forEach(room => {\n    const currentTemp = flow.get(`room_${room}_current_temp`) || null;\n    const targetTemp = flow.get(`room_${room}_target_temp`) || null;\n    const heating = flow.get(`room_${room}_heating`) || false;\n    const boost = flow.get(`boost_${room}_active`) || false;\n    \n    roomStatus.push({\n        name: room,\n        current_temp: currentTemp,\n        target_temp: targetTemp,\n        heating: heating,\n        boost: boost\n    });\n});\n\nmsg.payload = {\n    status: 'ok',\n    timestamp: new Date().toISOString(),\n    rooms: roomStatus,\n    mode: {\n        current: flow.get('current_mode') || 'work',\n        overrides: flow.get('current_overrides') || []\n    },\n    calendar: {\n        active_events: calendarEvents.filter(e => e.active).length,\n        total_events: calendarEvents.length\n    },\n    alerts: {\n        total: alertHistory.length,\n        unacknowledged: alertHistory.filter(a => !a.acknowledged).length\n    },\n    services: {\n        nodered: true,\n        mosquitto: flow.get('service_mosquitto_online') || false,\n        baikal: flow.get('service_baikal_online') || false\n    }\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 370,
    "y": 80,
    "wires": [
      [
        "api_response"
      ]
    ]
  },
  {
    "id": "api_mode_get_in",
    "type": "http in",
    "z": "tab_api",
    "name": "GET /api/mode",
    "url": "/api/mode",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 140,
    "y": 160,
    "wires": [
      [
        "api_mode_get_handler"
      ]
    ]
  },
  {
    "id": "api_mode_get_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Mode GET Handler",
    "func": "const modes = global.get('modes');\n\nmsg.payload = {\n    current: flow.get('current_mode') || 'work',\n    overrides: flow.get('current_overrides') || [],\n    available: Object.keys(modes?.events || {}),\n    priority: modes?.event_priority || {}\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 160,
    "wires": [
      [
        "api_response"
      ]
    ]
  },
  {
    "id": "api_mode_post_in",
    "type": "http in",
    "z": "tab_api",
    "name": "POST /api/mode",
    "url": "/api/mode",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 140,
    "y": 220,
    "wires": [
      [
        "api_mode_post_handler"
      ]
    ]
  },
  {
    "id": "api_mode_post_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Mode POST Handler",
    "func": "const newMode = msg.payload.mode;\n\nif (!newMode) {\n    msg.statusCode = 400;\n    msg.payload = { error: 'Missing mode parameter' };\n    return msg;\n}\n\nconst modes = global.get('modes');\nconst availableModes = Object.keys(modes?.events || {});\n\nif (!availableModes.includes(newMode)) {\n    msg.statusCode = 400;\n    msg.payload = { error: `Invalid mode: ${newMode}` };\n    return msg;\n}\n\n// Trigger mode change\nflow.set('current_mode', newMode);\n\n// Send MQTT message to trigger recalculation\nnode.send({\n    topic: 'internal/recalc_mode',\n    payload: { trigger: 'api', mode: newMode }\n});\n\nmsg.payload = {\n    status: 'ok',\n    mode: newMode,\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 220,
    "wires": [
      [
        "api_response"
      ]
    ]
  },
  {
    "id": "api_override_in",
    "type": "http in",
    "z": "tab_api",
    "name": "POST /api/override",
    "url": "/api/override",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 150,
    "y": 300,
    "wires": [
      [
        "api_override_handler"
      ]
    ]
  },
  {
    "id": "api_override_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Override Handler",
    "func": "const room = msg.payload.room;\nconst temp = msg.payload.temp;\nconst duration = msg.payload.duration || 60;\n\nif (!room || !temp) {\n    msg.statusCode = 400;\n    msg.payload = { error: 'Missing room or temp parameter' };\n    return [msg, null];\n}\n\n// Create response message (clone original msg)\nconst responseMsg = {\n    ...msg,\n    payload: {\n        status: 'ok',\n        room: room,\n        temp: temp,\n        duration: duration,\n        timestamp: new Date().toISOString()\n    }\n};\n\n// Create MQTT messages array\nconst mqttMsgs = [\n    {\n        topic: `virt/boost/${room}/minutes`,\n        payload: duration,\n        retain: true\n    },\n    {\n        topic: `virt/boost/${room}/target_temp`,\n        payload: parseFloat(temp),\n        retain: true\n    }\n];\n\nnode.warn(`[api] Override: ${room} ${temp}¬∞C for ${duration}min`);\n\nreturn [responseMsg, mqttMsgs];",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 300,
    "wires": [
      [
        "api_response"
      ],
      [
        "api_override_split"
      ]
    ]
  },
  {
    "id": "api_override_split",
    "type": "split",
    "z": "tab_api",
    "name": "Split MQTT Messages",
    "splt": "\\n",
    "spltType": "str",
    "arraySplt": 1,
    "arraySpltType": "len",
    "stream": false,
    "addname": "",
    "x": 630,
    "y": 340,
    "wires": [
      [
        "api_override_mqtt"
      ]
    ]
  },
  {
    "id": "api_override_mqtt",
    "type": "mqtt out",
    "z": "tab_api",
    "name": "Override MQTT",
    "topic": "",
    "qos": "1",
    "retain": "true",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 830,
    "y": 340,
    "wires": []
  },
  {
    "id": "api_events_in",
    "type": "http in",
    "z": "tab_api",
    "name": "GET /api/events/upcoming",
    "url": "/api/events/upcoming",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 170,
    "y": 380,
    "wires": [
      [
        "api_events_handler"
      ]
    ]
  },
  {
    "id": "api_events_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Events Handler",
    "func": "const calendarEvents = global.get('calendarEvents') || [];\nconst now = new Date();\n\nconst upcoming = calendarEvents\n    .filter(e => new Date(e.start) > now)\n    .sort((a, b) => new Date(a.start) - new Date(b.start))\n    .slice(0, 10);\n\nconst active = calendarEvents.filter(e => e.active);\n\nmsg.payload = {\n    active: active,\n    upcoming: upcoming,\n    timestamp: now.toISOString()\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 400,
    "y": 380,
    "wires": [
      [
        "api_response"
      ]
    ]
  },
  {
    "id": "api_alerts_ack_in",
    "type": "http in",
    "z": "tab_api",
    "name": "POST /api/alerts/ack",
    "url": "/api/alerts/ack",
    "method": "post",
    "upload": false,
    "swaggerDoc": "",
    "x": 160,
    "y": 460,
    "wires": [
      [
        "api_alerts_ack_handler"
      ]
    ]
  },
  {
    "id": "api_alerts_ack_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Alerts ACK Handler",
    "func": "const alertId = msg.payload.id;\n\nif (!alertId) {\n    msg.statusCode = 400;\n    msg.payload = { error: 'Missing alert id' };\n    return msg;\n}\n\nconst alertHistory = global.get('alertHistory') || [];\nconst alert = alertHistory.find(a => a.timestamp === alertId);\n\nif (!alert) {\n    msg.statusCode = 404;\n    msg.payload = { error: 'Alert not found' };\n    return msg;\n}\n\nalert.acknowledged = true;\nalert.acknowledgedAt = new Date().toISOString();\n\nglobal.set('alertHistory', alertHistory);\n\nmsg.payload = {\n    status: 'ok',\n    alert: alert\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 400,
    "y": 460,
    "wires": [
      [
        "api_response"
      ]
    ]
  },
  {
    "id": "api_response",
    "type": "http response",
    "z": "tab_api",
    "name": "JSON Response",
    "statusCode": "",
    "headers": {
      "content-type": "application/json"
    },
    "x": 630,
    "y": 280,
    "wires": []
  },
  {
    "id": "api_weather_current_in",
    "type": "http in",
    "z": "tab_api",
    "name": "GET /api/weather/current",
    "url": "/api/weather/current",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 170,
    "y": 400,
    "wires": [
      [
        "api_weather_current_handler"
      ]
    ]
  },
  {
    "id": "api_weather_current_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Weather Current Handler",
    "func": "const weatherCurrent = global.get('weather_current') || null;\n\nif (!weatherCurrent) {\n    msg.statusCode = 503;\n    msg.payload = {\n        success: false,\n        error: 'Weather data not available',\n        message: 'Please wait for first weather update'\n    };\n    return msg;\n}\n\nmsg.payload = {\n    success: true,\n    data: weatherCurrent,\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 430,
    "y": 400,
    "wires": [
      [
        "api_response"
      ]
    ]
  },
  {
    "id": "api_weather_forecast_in",
    "type": "http in",
    "z": "tab_api",
    "name": "GET /api/weather/forecast",
    "url": "/api/weather/forecast",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 170,
    "y": 460,
    "wires": [
      [
        "api_weather_forecast_handler"
      ]
    ]
  },
  {
    "id": "api_weather_forecast_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Weather Forecast Handler",
    "func": "const weatherForecast = global.get('weather_forecast') || [];\n\nif (weatherForecast.length === 0) {\n    msg.statusCode = 503;\n    msg.payload = {\n        success: false,\n        error: 'Forecast data not available',\n        message: 'Please wait for first weather update'\n    };\n    return msg;\n}\n\nmsg.payload = {\n    success: true,\n    data: weatherForecast,\n    count: weatherForecast.length,\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 430,
    "y": 460,
    "wires": [
      [
        "api_response"
      ]
    ]
  },
  {
    "id": "api_mode_current_in",
    "type": "http in",
    "z": "tab_api",
    "name": "GET /api/mode/current",
    "url": "/api/mode/current",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 160,
    "y": 520,
    "wires": [
      [
        "api_mode_current_handler"
      ]
    ]
  },
  {
    "id": "api_mode_current_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Mode Current Handler",
    "func": "const activeRegimes = global.get('activeRegimesByRoom') || {};\nconst cfg = global.get('modesCfg');\n\nif (!cfg) {\n    msg.statusCode = 503;\n    msg.payload = {\n        success: false,\n        error: 'Configuration not loaded'\n    };\n    return msg;\n}\n\n// Determine dominant mode based on most common regime\nconst regimeCounts = {};\nObject.values(activeRegimes).forEach(regime => {\n    regimeCounts[regime] = (regimeCounts[regime] || 0) + 1;\n});\n\nconst dominantRegime = Object.keys(regimeCounts).reduce((a, b) => \n    regimeCounts[a] > regimeCounts[b] ? a : b, 'PT'\n);\n\nmsg.payload = {\n    success: true,\n    data: {\n        regimesByRoom: activeRegimes,\n        dominantRegime: dominantRegime,\n        availableModes: Object.keys(cfg.modes || {}),\n        rooms: cfg.rooms || []\n    },\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 420,
    "y": 520,
    "wires": [
      [
        "api_response"
      ]
    ]
  },
  {
    "id": "api_rooms_temps_in",
    "type": "http in",
    "z": "tab_api",
    "name": "GET /api/rooms/temps",
    "url": "/api/rooms/temps",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 160,
    "y": 580,
    "wires": [
      [
        "api_rooms_temps_handler"
      ]
    ]
  },
  {
    "id": "api_rooms_temps_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Rooms Temps Handler",
    "func": "const cfg = global.get('modesCfg');\n\nif (!cfg || !cfg.rooms) {\n    msg.statusCode = 503;\n    msg.payload = {\n        success: false,\n        error: 'Configuration not loaded'\n    };\n    return msg;\n}\n\n// Placeholder - would normally read from MQTT/sensors\nconst roomTemps = {};\ncfg.rooms.forEach(room => {\n    // Mock current and target temps\n    roomTemps[room] = {\n        current: Math.round((18 + Math.random() * 4) * 10) / 10,\n        target: 20.0,\n        status: 'heating' // or 'idle', 'cooling'\n    };\n});\n\nmsg.payload = {\n    success: true,\n    data: roomTemps,\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 420,
    "y": 580,
    "wires": [
      [
        "api_response"
      ]
    ]
  },
  {
    "id": "api_rooms_capabilities_in",
    "type": "http in",
    "z": "tab_api",
    "name": "GET /api/rooms/capabilities",
    "url": "/api/rooms/capabilities",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 160,
    "y": 620,
    "wires": [
      [
        "api_rooms_capabilities_handler"
      ]
    ]
  },
  {
    "id": "api_rooms_capabilities_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Rooms Capabilities Handler",
    "func": "const cfg = global.get('modesCfg');\n\nif (!cfg) {\n    msg.statusCode = 503;\n    msg.payload = {\n        success: false,\n        error: 'Configuration not loaded'\n    };\n    return msg;\n}\n\nconst capabilities = cfg.room_capabilities || {};\nconst rooms = cfg.rooms || [];\nconst labels = cfg.room_labels || {};\n\nmsg.payload = {\n    success: true,\n    data: {\n        capabilities: capabilities,\n        rooms: rooms,\n        labels: labels\n    },\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 420,
    "y": 620,
    "wires": [
      [
        "api_response"
      ]
    ]
  },
  {
    "id": "api_calendar_events_in",
    "type": "http in",
    "z": "tab_api",
    "name": "GET /api/calendar/events",
    "url": "/api/calendar/events",
    "method": "get",
    "upload": false,
    "swaggerDoc": "",
    "x": 170,
    "y": 640,
    "wires": [
      [
        "api_calendar_events_handler"
      ]
    ]
  },
  {
    "id": "api_calendar_events_handler",
    "type": "function",
    "z": "tab_api",
    "name": "Calendar Events Handler",
    "func": "const events = global.get('calendarEvents') || [];\n\nconst activeEvents = events.filter(e => e.active);\nconst upcomingEvents = events.filter(e => !e.active && new Date(e.start) > new Date());\n\nmsg.payload = {\n    success: true,\n    data: {\n        active: activeEvents,\n        upcoming: upcomingEvents.slice(0, 10),\n        totalActive: activeEvents.length,\n        totalUpcoming: upcomingEvents.length\n    },\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 430,
    "y": 640,
    "wires": [
      [
        "api_response"
      ]
    ]
  },
  {
    "id": "weather_trigger",
    "type": "cronplus",
    "z": "tab_weather",
    "name": "Every 15min",
    "outputField": "payload",
    "timeZone": "",
    "storeName": "",
    "commandResponseMsgOutput": "output1",
    "outputs": 1,
    "options": [
      {
        "name": "startup",
        "topic": "startup",
        "payloadType": "default",
        "payload": "",
        "expressionType": "cron",
        "expression": "0 * * * * *",
        "location": "",
        "offset": "0",
        "solarType": "all",
        "solarEvents": "sunrise,sunset"
      },
      {
        "name": "poll",
        "topic": "poll",
        "payloadType": "default",
        "payload": "",
        "expressionType": "cron",
        "expression": "0 */15 * * * *",
        "location": "",
        "offset": "0",
        "solarType": "all",
        "solarEvents": "sunrise,sunset"
      }
    ],
    "x": 150,
    "y": 100,
    "wires": [
      [
        "weather_prepare_request"
      ]
    ]
  },
  {
    "id": "weather_prepare_request",
    "type": "function",
    "z": "tab_weather",
    "name": "Prepare API Request",
    "func": "const apiKey = env.get('OPENWEATHER_API_KEY');\nconst lat = env.get('WEATHER_LAT') || '48.1486';\nconst lon = env.get('WEATHER_LON') || '17.1077';\nconst units = 'metric';\nconst lang = 'sk';\n\nif (!apiKey) {\n    node.error('[weather] OPENWEATHER_API_KEY not set');\n    return null;\n}\n\n// OpenWeatherMap One Call API 3.0 (free tier)\nconst url = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=${units}&lang=${lang}&appid=${apiKey}`;\nconst forecastUrl = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&units=${units}&lang=${lang}&appid=${apiKey}`;\n\nmsg.url = url;\nmsg.forecastUrl = forecastUrl;\n\nnode.warn(`[weather] Fetching weather for lat=${lat}, lon=${lon}`);\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 350,
    "y": 100,
    "wires": [
      [
        "weather_fetch_current"
      ]
    ]
  },
  {
    "id": "weather_fetch_current",
    "type": "http request",
    "z": "tab_weather",
    "name": "Fetch Current",
    "method": "GET",
    "ret": "obj",
    "paytoqs": "ignore",
    "url": "",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "x": 560,
    "y": 100,
    "wires": [
      [
        "weather_parse_current"
      ]
    ]
  },
  {
    "id": "weather_parse_current",
    "type": "function",
    "z": "tab_weather",
    "name": "Parse Current Weather",
    "func": "const data = msg.payload;\nconst forecastUrl = msg.forecastUrl;\n\nif (!data || !data.main) {\n    node.error('[weather] Invalid response from API');\n    return null;\n}\n\n// Convert wind degree to direction (S, SV, V, JV, J, JZ, Z, SZ)\nfunction getWindDirection(deg) {\n    const directions = ['S', 'SV', 'V', 'JV', 'J', 'JZ', 'Z', 'SZ'];\n    const index = Math.round(((deg % 360) / 45)) % 8;\n    return directions[index];\n}\n\nconst windDeg = data.wind?.deg || 0;\nconst windSpeed = Math.round(data.wind?.speed * 3.6 * 10) / 10;\n\nconst current = {\n    location: data.name || 'Unknown',\n    country: data.sys?.country || 'SK',\n    temp: Math.round(data.main.temp * 10) / 10,\n    feels_like: Math.round(data.main.feels_like * 10) / 10,\n    temp_min: Math.round(data.main.temp_min * 10) / 10,\n    temp_max: Math.round(data.main.temp_max * 10) / 10,\n    pressure: data.main.pressure,\n    humidity: data.main.humidity,\n    weather: data.weather?.[0]?.main || 'Unknown',\n    description: data.weather?.[0]?.description || '',\n    icon: data.weather?.[0]?.icon || '01d',\n    wind_speed: windSpeed, // m/s to km/h\n    wind_deg: windDeg,\n    wind_direction: getWindDirection(windDeg),\n    clouds: data.clouds?.all || 0,\n    visibility: data.visibility || 0,\n    sunrise: data.sys?.sunrise ? new Date(data.sys.sunrise * 1000).toISOString() : null,\n    sunset: data.sys?.sunset ? new Date(data.sys.sunset * 1000).toISOString() : null,\n    timestamp: new Date().toISOString(),\n    dt: data.dt ? new Date(data.dt * 1000).toISOString() : new Date().toISOString()\n};\n\nnode.warn(`[weather] Current: ${current.temp}¬∞C, ${current.description}, Wind: ${current.wind_speed} km/h ${current.wind_direction}`);\n\n// Return 2 messages: one for MQTT current, one for forecast fetch\nreturn [\n    {payload: current, topic: 'virt/weather/current'},  // To MQTT\n    {url: forecastUrl, currentWeather: current}         // To forecast HTTP request\n];",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 770,
    "y": 100,
    "wires": [
      [
        "weather_octant_calc"
      ],
      [
        "weather_fetch_forecast"
      ]
    ]
  },
  {
    "id": "weather_save_current",
    "type": "change",
    "z": "tab_weather",
    "name": "Save to Global Context",
    "rules": [
      {
        "t": "set",
        "p": "weather_current",
        "pt": "global",
        "to": "payload",
        "tot": "msg"
      }
    ],
    "action": "",
    "property": "",
    "from": "",
    "to": "",
    "reg": false,
    "x": 870,
    "y": 300,
    "wires": [
      [
        "weather_mqtt_current"
      ]
    ]
  },
  {
    "id": "weather_mqtt_current",
    "type": "mqtt out",
    "z": "tab_weather",
    "name": "virt/weather/current",
    "topic": "virt/weather/current",
    "qos": "1",
    "retain": "true",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 1130,
    "y": 300,
    "wires": []
  },
  {
    "id": "weather_fetch_forecast",
    "type": "http request",
    "z": "tab_weather",
    "name": "Fetch Forecast",
    "method": "GET",
    "ret": "obj",
    "paytoqs": "ignore",
    "url": "",
    "tls": "",
    "persist": false,
    "proxy": "",
    "authType": "",
    "senderr": false,
    "x": 240,
    "y": 180,
    "wires": [
      [
        "weather_parse_forecast"
      ]
    ]
  },
  {
    "id": "weather_parse_forecast",
    "type": "function",
    "z": "tab_weather",
    "name": "Parse Forecast (4 times)",
    "func": "const data = msg.payload;\n\nif (!data || !data.list) {\n    node.error('[weather] Invalid forecast response');\n    return null;\n}\n\n// Get forecast for 04:00, 10:00, 16:00, 22:00 today\nconst now = new Date();\nconst today = now.toISOString().split('T')[0];\n\nconst targetHours = [4, 10, 16, 22];\nconst forecasts = [];\n\n// OpenWeatherMap gives 3-hour intervals\n// Find closest forecast to each target hour\ntargetHours.forEach(targetHour => {\n    const targetTime = new Date(`${today}T${String(targetHour).padStart(2, '0')}:00:00Z`);\n    \n    // Find forecast closest to target time\n    let closestForecast = null;\n    let minDiff = Infinity;\n    \n    data.list.forEach(item => {\n        const itemTime = new Date(item.dt * 1000);\n        const diff = Math.abs(itemTime - targetTime);\n        \n        if (diff < minDiff && itemTime.getHours() >= targetHour - 2 && itemTime.getHours() <= targetHour + 2) {\n            minDiff = diff;\n            closestForecast = item;\n        }\n    });\n    \n    if (closestForecast) {\n        forecasts.push({\n            hour: targetHour,\n            temp: Math.round(closestForecast.main.temp * 10) / 10,\n            weather: closestForecast.weather?.[0]?.main || 'Unknown',\n            description: closestForecast.weather?.[0]?.description || '',\n            icon: closestForecast.weather?.[0]?.icon || '01d',\n            dt: new Date(closestForecast.dt * 1000).toISOString()\n        });\n    }\n});\n\nnode.warn(`[weather] Forecast: ${forecasts.length} time slots`);\n\nmsg.payload = forecasts;\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 510,
    "y": 180,
    "wires": [
      [
        "weather_save_forecast",
        "fe0da8e0534108cf"
      ]
    ]
  },
  {
    "id": "weather_save_forecast",
    "type": "change",
    "z": "tab_weather",
    "name": "Save to Global Context",
    "rules": [
      {
        "t": "set",
        "p": "weather_forecast",
        "pt": "global",
        "to": "payload",
        "tot": "msg"
      }
    ],
    "action": "",
    "property": "",
    "from": "",
    "to": "",
    "reg": false,
    "x": 310,
    "y": 300,
    "wires": [
      [
        "weather_mqtt_forecast"
      ]
    ]
  },
  {
    "id": "weather_mqtt_forecast",
    "type": "mqtt out",
    "z": "tab_weather",
    "name": "virt/weather/forecast",
    "topic": "virt/weather/forecast",
    "qos": "1",
    "retain": "true",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 560,
    "y": 300,
    "wires": []
  },
  {
    "id": "weather_octant_calc",
    "type": "function",
    "z": "tab_weather",
    "name": "Calculate Octant",
    "func": "// Convert wind_deg to octant (N/NE/E/SE/S/SW/W/NW)\nfunction degToOctant(deg) {\n    const octants = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];\n    const normalized = ((deg % 360) + 360) % 360; // Handle negative\n    const index = Math.round(normalized / 45) % 8;\n    return octants[index];\n}\n\nif (msg.payload && msg.payload.wind_deg !== undefined) {\n    const windDeg = msg.payload.wind_deg;\n    const windSpeedMs = msg.payload.wind_speed / 3.6; // km/h to m/s\n    const octant = degToOctant(windDeg);\n    \n    msg.payload.octant = octant;\n    msg.payload.wind_speed_ms = Math.round(windSpeedMs * 10) / 10;\n    \n    node.warn(`[weather] Octant: ${windDeg}¬∞ ‚Üí ${octant}, wind: ${windSpeedMs} m/s`);\n    \n    // Store in global context for correlation\n    const weatherData = {\n        temp_c: msg.payload.temp,\n        wind_speed_ms: windSpeedMs,\n        wind_dir_deg: windDeg,\n        octant: octant,\n        timestamp: new Date().toISOString()\n    };\n    \n    global.set('weatherCurrent', weatherData);\n}\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 850,
    "y": 200,
    "wires": [
      [
        "weather_save_current"
      ]
    ]
  },
  {
    "id": "fe0da8e0534108cf",
    "type": "mqtt out",
    "z": "tab_weather",
    "name": "",
    "topic": "virt/weather/hourly",
    "qos": "1",
    "retain": "true",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 550,
    "y": 380,
    "wires": []
  },
  {
    "id": "weather_widget_current",
    "type": "mqtt in",
    "z": "tab_dashboard",
    "name": "Weather Current",
    "topic": "virt/weather/current",
    "qos": "1",
    "datatype": "json",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 150,
    "y": 100,
    "wires": [
      [
        "weather_widget_template"
      ]
    ]
  },
  {
    "id": "weather_widget_forecast",
    "type": "mqtt in",
    "z": "tab_dashboard",
    "name": "Weather Forecast",
    "topic": "virt/weather/forecast",
    "qos": "1",
    "datatype": "json",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 160,
    "y": 160,
    "wires": [
      [
        "weather_combine"
      ]
    ]
  },
  {
    "id": "weather_combine",
    "type": "function",
    "z": "tab_dashboard",
    "name": "Combine Data",
    "func": "// Store forecast data\nif (msg.topic === 'virt/weather/forecast') {\n    global.set('weatherForecast', msg.payload);\n    return null;\n}\n\n// Get current from global\nconst current = global.get('weatherCurrent') || msg.payload;\nconst forecast = global.get('weatherForecast') || [];\n\nmsg.payload = {\n    current: current,\n    forecast: forecast\n};\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 370,
    "y": 130,
    "wires": [
      [
        "weather_widget_template"
      ]
    ]
  },
  {
    "id": "weather_widget_template",
    "type": "ui_template",
    "z": "tab_dashboard",
    "group": "weather_group",
    "name": "Weather Card",
    "order": 1,
    "width": "6",
    "height": "6",
    "format": "<style>\n.weather-card {\n    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);\n    border-radius: 16px;\n    padding: 24px;\n    color: white;\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    box-shadow: 0 8px 32px rgba(0,0,0,0.3);\n}\n.weather-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 20px;\n}\n.weather-location {\n    font-size: 24px;\n    font-weight: 300;\n}\n.weather-main {\n    display: flex;\n    align-items: center;\n    justify-content: space-around;\n    margin: 30px 0;\n}\n.weather-icon {\n    font-size: 80px;\n}\n.weather-temp {\n    font-size: 72px;\n    font-weight: 200;\n}\n.weather-details {\n    display: flex;\n    justify-content: space-around;\n    margin: 20px 0;\n    font-size: 14px;\n}\n.weather-detail {\n    text-align: center;\n}\n.weather-detail-value {\n    font-size: 18px;\n    font-weight: 500;\n}\n.weather-forecast {\n    display: flex;\n    justify-content: space-around;\n    margin-top: 24px;\n    padding-top: 20px;\n    border-top: 1px solid rgba(255,255,255,0.2);\n}\n.forecast-item {\n    text-align: center;\n}\n.forecast-time {\n    font-size: 14px;\n    opacity: 0.8;\n}\n.forecast-icon {\n    font-size: 32px;\n    margin: 8px 0;\n}\n.forecast-temp {\n    font-size: 16px;\n    font-weight: 500;\n}\n.weather-timestamp {\n    text-align: right;\n    font-size: 11px;\n    opacity: 0.6;\n    margin-top: 16px;\n}\n</style>\n\n<div class=\"weather-card\" ng-if=\"msg.payload.current\">\n    <div class=\"weather-header\">\n        <div class=\"weather-location\">{{msg.payload.current.location}}</div>\n        <div>{{msg.payload.current.dt | date:'HH:mm'}}</div>\n    </div>\n    \n    <div class=\"weather-main\">\n        <div class=\"weather-icon\">\n            <img ng-src=\"https://openweathermap.org/img/wn/{{msg.payload.current.icon}}@2x.png\" \n                 style=\"width: 100px; height: 100px; filter: brightness(1.2);\">\n        </div>\n        <div class=\"weather-temp\">{{msg.payload.current.temp}}¬∞C</div>\n    </div>\n    \n    <div style=\"text-align: center; font-size: 18px; margin-bottom: 20px; opacity: 0.9;\">\n        {{msg.payload.current.description}}\n    </div>\n    \n    <div class=\"weather-details\">\n        <div class=\"weather-detail\">\n            <div style=\"opacity: 0.7;\">üíß Vlhkos≈•</div>\n            <div class=\"weather-detail-value\">{{msg.payload.current.humidity}}%</div>\n        </div>\n        <div class=\"weather-detail\">\n            <div style=\"opacity: 0.7;\">üí® Vietor</div>\n            <div class=\"weather-detail-value\">{{msg.payload.current.wind_speed}} km/h {{msg.payload.current.wind_direction}}</div>\n        </div>\n        <div class=\"weather-detail\">\n            <div style=\"opacity: 0.7;\">üå°Ô∏è Tlak</div>\n            <div class=\"weather-detail-value\">{{msg.payload.current.pressure}} hPa</div>\n        </div>\n    </div>\n    \n    <div class=\"weather-forecast\" ng-if=\"msg.payload.forecast.length > 0\">\n        <div class=\"forecast-item\" ng-repeat=\"f in msg.payload.forecast\">\n            <div class=\"forecast-time\">{{f.hour}}:00</div>\n            <div class=\"forecast-icon\">\n                <img ng-src=\"https://openweathermap.org/img/wn/{{f.icon}}.png\" \n                     style=\"width: 40px; height: 40px;\">\n            </div>\n            <div class=\"forecast-temp\">{{f.temp}}¬∞C</div>\n        </div>\n    </div>\n    \n    <div class=\"weather-timestamp\">\n        Aktualizovan√©: {{msg.payload.current.timestamp | date:'dd.MM.yyyy HH:mm:ss'}}\n    </div>\n</div>\n\n<div ng-if=\"!msg.payload.current\" style=\"text-align: center; padding: 40px; color: #999;\">\n    Naƒç√≠tavam poƒçasie...\n</div>",
    "storeOutMessages": false,
    "fwdInMessages": false,
    "resendOnRefresh": true,
    "templateScope": "local",
    "x": 580,
    "y": 130,
    "wires": [
      []
    ]
  },
  {
    "id": "holidays_init",
    "type": "inject",
    "z": "tab_holidays",
    "name": "Initialize at startup",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": "8",
    "topic": "",
    "payload": "{}",
    "payloadType": "json",
    "x": 160,
    "y": 100,
    "wires": [
      [
        "holidays_compute"
      ]
    ]
  },
  {
    "id": "holidays_init_today_check",
    "type": "inject",
    "z": "tab_holidays",
    "name": "Check today at startup",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": "9",
    "topic": "",
    "payload": "{}",
    "payloadType": "json",
    "x": 170,
    "y": 180,
    "wires": [
      [
        "holidays_check_today"
      ]
    ]
  },
  {
    "id": "holidays_compute",
    "type": "function",
    "z": "tab_holidays",
    "name": "Compute Holidays Cache",
    "func": "// Load configuration\nconst cfg = global.get('modesCfg');\nif (!cfg || !cfg.holidays) {\n    node.warn('[holidays] No configuration loaded');\n    return null;\n}\n\n// Easter calculation using Butcher-Meeus algorithm\n// Returns Date object for Easter Sunday of given year\nfunction calculateEaster(year) {\n    const a = year % 19;\n    const b = Math.floor(year / 100);\n    const c = year % 100;\n    const d = Math.floor(b / 4);\n    const e = b % 4;\n    const f = Math.floor((b + 8) / 25);\n    const g = Math.floor((b - f + 1) / 3);\n    const h = (19 * a + b - d - g + 15) % 30;\n    const i = Math.floor(c / 4);\n    const k = c % 4;\n    const l = (32 + 2 * e + 2 * i - h - k) % 7;\n    const m = Math.floor((a + 11 * h + 22 * l) / 451);\n    const month = Math.floor((h + l - 7 * m + 114) / 31); // 3=March, 4=April\n    const day = ((h + l - 7 * m + 114) % 31) + 1;\n    \n    return new Date(year, month - 1, day);\n}\n\n// Generate holiday cache for current year and next 2 years\nconst now = new Date();\nconst currentYear = now.getFullYear();\nconst holidayCache = {};\n\nfor (let year = currentYear; year <= currentYear + 2; year++) {\n    holidayCache[year] = [];\n    \n    // Add fixed holidays\n    if (cfg.holidays.static && cfg.holidays.static.fixed) {\n        cfg.holidays.static.fixed.forEach(dateStr => {\n            // Format: \"MM-DD\"\n            holidayCache[year].push(`${year}-${dateStr}`);\n        });\n    }\n    \n    // Add moveable holidays (Easter-based)\n    if (cfg.holidays.static && cfg.holidays.static.moveable) {\n        const easter = calculateEaster(year);\n        \n        cfg.holidays.static.moveable.forEach(holiday => {\n            if (holiday.base === 'easter') {\n                const offset = holiday.offset_days || 0;\n                const date = new Date(easter);\n                date.setDate(date.getDate() + offset);\n                \n                const month = String(date.getMonth() + 1).padStart(2, '0');\n                const day = String(date.getDate()).padStart(2, '0');\n                holidayCache[year].push(`${year}-${month}-${day}`);\n            }\n        });\n    }\n}\n\n// Store in global context\nglobal.set('holidayCache', holidayCache);\n\n// Create Set for fast lookup of current year\nconst currentYearSet = new Set(holidayCache[currentYear]);\nglobal.set('holidaySet', currentYearSet);\n\nnode.log(`[holidays] Computed ${holidayCache[currentYear].length} holidays for ${currentYear}`);\nnode.log(`[holidays] Easter ${currentYear}: ${calculateEaster(currentYear).toISOString().split('T')[0]}`);\n\nmsg.payload = {\n    status: 'success',\n    years: Object.keys(holidayCache),\n    count: holidayCache[currentYear].length,\n    holidays: holidayCache[currentYear]\n};\n\nreturn msg;",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 410,
    "y": 100,
    "wires": [
      [
        "holidays_mqtt_out"
      ]
    ]
  },
  {
    "id": "holidays_mqtt_out",
    "type": "mqtt out",
    "z": "tab_holidays",
    "name": "Publish Holiday Status",
    "topic": "virt/system/holidays_loaded",
    "qos": "1",
    "retain": "true",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 680,
    "y": 100,
    "wires": []
  },
  {
    "id": "holidays_check_trigger",
    "type": "inject",
    "z": "tab_holidays",
    "name": "Check daily at midnight",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "00 00 * * *",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "{}",
    "payloadType": "json",
    "x": 180,
    "y": 220,
    "wires": [
      [
        "holidays_check_today"
      ]
    ]
  },
  {
    "id": "holidays_check_today",
    "type": "function",
    "z": "tab_holidays",
    "name": "Check if Today is Holiday",
    "func": "const holidaySet = global.get('holidaySet') || new Set();\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst today = `${year}-${month}-${day}`;\n\nconst isHoliday = holidaySet.has(today);\n\nnode.log(`[holidays] Today ${today}: ${isHoliday ? 'HOLIDAY' : 'regular day'}`);\n\nmsg.payload = {\n    date: today,\n    isHoliday: isHoliday,\n    timestamp: now.toISOString()\n};\n\n// Store in global for resolver access\nglobal.set('todayIsHoliday', isHoliday);\n\nreturn msg;",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 430,
    "y": 200,
    "wires": [
      [
        "holidays_today_mqtt_out"
      ]
    ]
  },
  {
    "id": "holidays_today_mqtt_out",
    "type": "mqtt out",
    "z": "tab_holidays",
    "name": "Publish Today Holiday Status",
    "topic": "virt/system/today_is_holiday",
    "qos": "1",
    "retain": "true",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 710,
    "y": 200,
    "wires": []
  },
  {
    "id": "holidays_manual_check",
    "type": "mqtt in",
    "z": "tab_holidays",
    "name": "Manual Check Request",
    "topic": "internal/holidays/check",
    "qos": "1",
    "datatype": "json",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": false,
    "rh": 0,
    "inputs": 0,
    "x": 170,
    "y": 300,
    "wires": [
      [
        "holidays_manual_check_fn"
      ]
    ]
  },
  {
    "id": "holidays_manual_check_fn",
    "type": "function",
    "z": "tab_holidays",
    "name": "Check Specific Date",
    "func": "const holidayCache = global.get('holidayCache') || {};\nconst dateStr = msg.payload.date; // Format: \"YYYY-MM-DD\"\n\nif (!dateStr) {\n    node.warn('[holidays] No date provided in check request');\n    return null;\n}\n\nconst year = parseInt(dateStr.split('-')[0]);\nconst yearHolidays = holidayCache[year] || [];\nconst isHoliday = yearHolidays.includes(dateStr);\n\nnode.log(`[holidays] Check ${dateStr}: ${isHoliday ? 'HOLIDAY' : 'regular day'}`);\n\nmsg.payload = {\n    date: dateStr,\n    isHoliday: isHoliday,\n    timestamp: new Date().toISOString()\n};\n\nreturn msg;",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 410,
    "y": 300,
    "wires": [
      [
        "holidays_manual_result"
      ]
    ]
  },
  {
    "id": "holidays_manual_result",
    "type": "mqtt out",
    "z": "tab_holidays",
    "name": "Publish Check Result",
    "topic": "virt/system/holiday_check_result",
    "qos": "1",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 660,
    "y": 300,
    "wires": []
  },
  {
    "id": "humidity_sensor_in",
    "type": "mqtt in",
    "z": "tab_humidity",
    "name": "Bathroom Humidity",
    "topic": "stat/sensor/kupelna_humidity/state",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 130,
    "y": 100,
    "wires": [
      [
        "humidity_controller"
      ]
    ]
  },
  {
    "id": "humidity_controller",
    "type": "function",
    "z": "tab_humidity",
    "name": "Hysteresis Controller",
    "func": "// Load configuration\nconst cfg = global.get('modesCfg');\nif (!cfg || !cfg.humidity || !cfg.humidity.kupelna) {\n    node.warn('[humidity] No configuration for kupelna');\n    return null;\n}\n\nconst config = cfg.humidity.kupelna;\nconst currentHumidity = parseFloat(msg.payload);\n\nif (isNaN(currentHumidity)) {\n    node.warn(`[humidity] Invalid humidity value: ${msg.payload}`);\n    return null;\n}\n\n// Get current state from flow context\nconst state = flow.get('humidity_state') || {\n    fanOn: false,\n    lastOnTime: 0,\n    lastOffTime: 0,\n    manualMode: false,\n    manualStartTime: 0\n};\n\nconst now = Date.now();\n\n// Check for manual override\nif (config.manual_detection && config.manual_detection.respect_manual_on) {\n    const fanState = flow.get('fan_state_manual');\n    if (fanState === true && !state.fanOn) {\n        // Manual turn on detected\n        state.manualMode = true;\n        state.manualStartTime = now;\n        node.log('[humidity] Manual fan activation detected');\n    }\n    \n    // Check manual timeout\n    if (state.manualMode) {\n        const maxManualMs = (config.manual_detection.max_manual_minutes || 120) * 60 * 1000;\n        if (now - state.manualStartTime > maxManualMs) {\n            node.log('[humidity] Manual mode timeout, switching to auto');\n            state.manualMode = false;\n        } else {\n            // Still in manual mode, don't control\n            node.log(`[humidity] Manual mode active (${Math.round((now - state.manualStartTime) / 60000)}min)`);\n            flow.set('humidity_state', state);\n            return null;\n        }\n    }\n}\n\n// Check cooldown period\nif (!state.fanOn) {\n    const cooldownMs = (config.cooldown_minutes || 10) * 60 * 1000;\n    if (now - state.lastOffTime < cooldownMs) {\n        const remainingMin = Math.round((cooldownMs - (now - state.lastOffTime)) / 60000);\n        node.log(`[humidity] In cooldown period (${remainingMin}min remaining)`);\n        flow.set('humidity_state', state);\n        return null;\n    }\n}\n\n// Hysteresis logic\nlet shouldTurnOn = false;\nlet shouldTurnOff = false;\n\nif (!state.fanOn && currentHumidity >= config.threshold_on) {\n    shouldTurnOn = true;\n} else if (state.fanOn && currentHumidity <= config.threshold_off) {\n    // Check minimum on time\n    const minOnMs = (config.min_on_minutes || 5) * 60 * 1000;\n    if (now - state.lastOnTime >= minOnMs) {\n        shouldTurnOff = true;\n    } else {\n        const remainingMin = Math.round((minOnMs - (now - state.lastOnTime)) / 60000);\n        node.log(`[humidity] Min on time not reached (${remainingMin}min remaining)`);\n    }\n}\n\n// Execute state change\nif (shouldTurnOn) {\n    node.warn(`[humidity] Turning fan ON (humidity: ${currentHumidity}% >= ${config.threshold_on}%)`);\n    state.fanOn = true;\n    state.lastOnTime = now;\n    state.manualMode = false;\n    \n    msg.topic = config.fan.cmd_topic;\n    msg.payload = config.fan.on_value;\n    \n    flow.set('humidity_state', state);\n    return msg;\n    \n} else if (shouldTurnOff) {\n    node.warn(`[humidity] Turning fan OFF (humidity: ${currentHumidity}% <= ${config.threshold_off}%)`);\n    state.fanOn = false;\n    state.lastOffTime = now;\n    \n    msg.topic = config.fan.cmd_topic;\n    msg.payload = config.fan.off_value;\n    \n    flow.set('humidity_state', state);\n    return msg;\n}\n\n// No action needed\nnode.log(`[humidity] No action (humidity: ${currentHumidity}%, fan: ${state.fanOn ? 'ON' : 'OFF'})`);\nflow.set('humidity_state', state);\n\nreturn null;",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 100,
    "wires": [
      [
        "humidity_fan_out"
      ]
    ]
  },
  {
    "id": "humidity_fan_out",
    "type": "mqtt out",
    "z": "tab_humidity",
    "name": "Fan Command",
    "topic": "",
    "qos": "1",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 620,
    "y": 100,
    "wires": []
  },
  {
    "id": "humidity_fan_state_in",
    "type": "mqtt in",
    "z": "tab_humidity",
    "name": "Fan State Feedback",
    "topic": "stat/switch/kupelna_fan/state",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 140,
    "y": 200,
    "wires": [
      [
        "humidity_fan_state_store"
      ]
    ]
  },
  {
    "id": "humidity_fan_state_store",
    "type": "function",
    "z": "tab_humidity",
    "name": "Store Fan State",
    "func": "// Store fan state for manual detection\nconst fanState = (msg.payload === 'ON' || msg.payload === true || msg.payload === 1);\nflow.set('fan_state_manual', fanState);\nnode.log(`[humidity] Fan state: ${fanState ? 'ON' : 'OFF'}`);\nreturn null;",
    "outputs": 0,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 390,
    "y": 200,
    "wires": []
  },
  {
    "id": "seen",
    "type": "function",
    "z": "tab_seed",
    "name": "Seen flags init",
    "func": "flow.set('seen', flow.get('seen')||{ targets:{}, enabled:{}, temps:{}, humidity:{}, boost:{}, weather:false, hourly:false });\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 340,
    "y": 60,
    "wires": [
      []
    ]
  },
  {
    "id": "in_target",
    "type": "mqtt in",
    "z": "tab_seed",
    "name": "virt/room/+/target_temp (retained)",
    "topic": "virt/room/+/target_temp",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 220,
    "y": 120,
    "wires": [
      [
        "mark_target"
      ]
    ]
  },
  {
    "id": "mark_target",
    "type": "function",
    "z": "tab_seed",
    "name": "mark seen target",
    "func": "const room = (msg.topic||'').split('/')[2];\nconst seen = flow.get('seen')||{ targets:{}, enabled:{}, weather:false, hourly:false };\nseen.targets[room]=true;\nflow.set('seen', seen);\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 500,
    "y": 120,
    "wires": [
      []
    ]
  },
  {
    "id": "in_enabled",
    "type": "mqtt in",
    "z": "tab_seed",
    "name": "stat/room/+/enabled OR stat/hvac/+/enabled",
    "topic": "stat/hvac/+/enabled",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 260,
    "y": 180,
    "wires": [
      [
        "mark_enabled"
      ]
    ]
  },
  {
    "id": "mark_enabled",
    "type": "function",
    "z": "tab_seed",
    "name": "mark seen enabled",
    "func": "const room = (msg.topic||'').split('/')[2];\nconst seen = flow.get('seen')||{ targets:{}, enabled:{}, weather:false, hourly:false };\nseen.enabled[room]=true;\nflow.set('seen', seen);\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 520,
    "y": 180,
    "wires": [
      []
    ]
  },
  {
    "id": "in_weather",
    "type": "mqtt in",
    "z": "tab_seed",
    "name": "virt/weather/current",
    "topic": "virt/weather/current",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 210,
    "y": 240,
    "wires": [
      [
        "mark_weather"
      ]
    ]
  },
  {
    "id": "mark_weather",
    "type": "function",
    "z": "tab_seed",
    "name": "mark seen weather",
    "func": "const seen = flow.get('seen')||{ targets:{}, enabled:{}, temps:{}, humidity:{}, boost:{}, weather:false, hourly:false };\nseen.weather=true;\nflow.set('seen', seen);\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 490,
    "y": 240,
    "wires": [
      []
    ]
  },
  {
    "id": "in_hourly",
    "type": "mqtt in",
    "z": "tab_seed",
    "name": "virt/weather/hourly or forecast",
    "topic": "virt/weather/hourly",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 230,
    "y": 300,
    "wires": [
      [
        "mark_hourly"
      ]
    ]
  },
  {
    "id": "mark_hourly",
    "type": "function",
    "z": "tab_seed",
    "name": "mark seen hourly",
    "func": "const seen = flow.get('seen')||{ targets:{}, enabled:{}, temps:{}, humidity:{}, boost:{}, weather:false, hourly:false };\nseen.hourly=true;\nflow.set('seen', seen);\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 490,
    "y": 300,
    "wires": [
      []
    ]
  },
  {
    "id": "in_humidity",
    "type": "mqtt in",
    "z": "tab_seed",
    "name": "stat/hvac/+/humidity (retained)",
    "topic": "stat/hvac/+/humidity",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 220,
    "y": 360,
    "wires": [
      [
        "mark_humidity"
      ]
    ]
  },
  {
    "id": "mark_humidity",
    "type": "function",
    "z": "tab_seed",
    "name": "mark seen humidity",
    "func": "const room = (msg.topic||'').split('/')[2];\nconst seen = flow.get('seen')||{ targets:{}, enabled:{}, temps:{}, humidity:{}, boost:{}, weather:false, hourly:false };\nseen.humidity = seen.humidity || {};\nseen.humidity[room]=true;\nflow.set('seen', seen);\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 500,
    "y": 360,
    "wires": [
      []
    ]
  },
  {
    "id": "in_temps",
    "type": "mqtt in",
    "z": "tab_seed",
    "name": "stat/hvac/+/current_temp (retained)",
    "topic": "stat/hvac/+/current_temp",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 230,
    "y": 420,
    "wires": [
      [
        "mark_temps"
      ]
    ]
  },
  {
    "id": "mark_temps",
    "type": "function",
    "z": "tab_seed",
    "name": "mark seen temps",
    "func": "const room = (msg.topic||'').split('/')[2];\nconst seen = flow.get('seen')||{ targets:{}, enabled:{}, temps:{}, humidity:{}, boost:{}, weather:false, hourly:false };\nseen.temps = seen.temps || {};\nseen.temps[room]=true;\nflow.set('seen', seen);\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 500,
    "y": 420,
    "wires": [
      []
    ]
  },
  {
    "id": "in_boost",
    "type": "mqtt in",
    "z": "tab_seed",
    "name": "virt/boost/+/minutes (retained)",
    "topic": "virt/boost/+/minutes",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 220,
    "y": 480,
    "wires": [
      [
        "mark_boost"
      ]
    ]
  },
  {
    "id": "mark_boost",
    "type": "function",
    "z": "tab_seed",
    "name": "mark seen boost",
    "func": "const room = (msg.topic||'').split('/')[2];\nconst seen = flow.get('seen')||{ targets:{}, enabled:{}, temps:{}, humidity:{}, boost:{}, weather:false, hourly:false };\nseen.boost = seen.boost || {};\nseen.boost[room]=true;\nflow.set('seen', seen);\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 490,
    "y": 480,
    "wires": [
      []
    ]
  },
  {
    "id": "inject_start",
    "type": "inject",
    "z": "tab_seed",
    "name": "on start + after 5s",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": "5",
    "topic": "",
    "x": 170,
    "y": 380,
    "wires": [
      [
        "seed_if_missing"
      ]
    ]
  },
  {
    "id": "seed_if_missing",
    "type": "function",
    "z": "tab_seed",
    "name": "Seed defaults if missing",
    "func": "const cfg = global.get('modesCfg');\nconst ROOMS = (cfg && Array.isArray(cfg.rooms) && cfg.rooms.length) ? cfg.rooms : [];\nconst capabilities = cfg?.room_capabilities || {};\nconst seen=flow.get('seen')||{targets:{},enabled:{},temps:{},humidity:{},boost:{},weather:false,hourly:false};\nconst out=[];\n\n// DYNAMIC CLEANUP: Detect rooms that exist in MQTT but NOT in current config\n// Combine all seen room names from different topic types\nconst allSeenRooms = new Set([\n    ...Object.keys(seen.targets || {}),\n    ...Object.keys(seen.enabled || {}),\n    ...Object.keys(seen.temps || {}),\n    ...Object.keys(seen.humidity || {}),\n    ...Object.keys(seen.boost || {})\n]);\n\n// Find rooms to remove: exist in MQTT but not in current modes.yaml\nconst removedRooms = Array.from(allSeenRooms).filter(r => !ROOMS.includes(r));\n\nif(removedRooms.length > 0) {\n    node.warn(`[seed] Removing ${removedRooms.length} obsolete rooms: ${removedRooms.join(', ')}`);\n}\n\nremovedRooms.forEach(r=>{\n    node.warn(`[seed] Cleaning up removed room: ${r}`);\n    // Delete all topics for this room (empty payload with retain=true)\n    out.push({topic:`virt/room/${r}/target_temp`, payload:'', retain:true});\n    out.push({topic:`virt/room/${r}/enabled`, payload:'', retain:true});\n    out.push({topic:`virt/room/${r}/override`, payload:'', retain:true});\n    out.push({topic:`virt/room/${r}/override_request`, payload:'', retain:true});\n    out.push({topic:`stat/hvac/${r}/enabled`, payload:'', retain:true});\n    out.push({topic:`stat/hvac/${r}/current_temp`, payload:'', retain:true});\n    out.push({topic:`stat/hvac/${r}/humidity`, payload:'', retain:true});\n    out.push({topic:`virt/boost/${r}/minutes`, payload:'', retain:true});\n    out.push({topic:`virt/boost/${r}/target_temp`, payload:'', retain:true});\n    out.push({topic:`virt/offset/${r}/value`, payload:'', retain:true});\n    out.push({topic:`cmd/hvac/${r}/setpoint`, payload:'', retain:true});\n    out.push({topic:`cmd/hvac/${r}/override`, payload:'', retain:true});\n    out.push({topic:`cmd/hvac/${r}/override_duration`, payload:'', retain:true});\n    out.push({topic:`cmd/hvac/${r}/enabled`, payload:'', retain:true});\n    \n    // Clean up from seen tracking\n    if(seen.targets) delete seen.targets[r];\n    if(seen.enabled) delete seen.enabled[r];\n    if(seen.temps) delete seen.temps[r];\n    if(seen.humidity) delete seen.humidity[r];\n    if(seen.boost) delete seen.boost[r];\n});\n\n// SEED: Initialize default topics for NEW rooms from config (only if not already seen)\nlet createdCount = 0;\nROOMS.forEach(r=>{\n    const cap = capabilities[r] || {};\n    \n    // Basic topics\n    if(!seen.targets || !seen.targets[r]){\n        out.push({topic:`virt/room/${r}/target_temp`, payload:'21', retain:true});\n        createdCount++;\n    }\n    if(!seen.enabled || !seen.enabled[r]){\n        out.push({topic:`stat/hvac/${r}/enabled`, payload:'true', retain:true});\n        createdCount++;\n    }\n    \n    // Temperature sensor (always create for rooms with temp_sensor=true)\n    if(cap.temp_sensor && (!seen.temps || !seen.temps[r])){\n        out.push({topic:`stat/hvac/${r}/current_temp`, payload:'20.0', retain:true});\n        createdCount++;\n    }\n    \n    // Humidity sensor (only if humidity_sensor=true)\n    if(cap.humidity_sensor && (!seen.humidity || !seen.humidity[r])){\n        const defaultHumidity = r === 'kupelna' ? '65' : (r === 'kuchyna' ? '52' : (r === 'detska' ? '48' : '45'));\n        out.push({topic:`stat/hvac/${r}/humidity`, payload:defaultHumidity, retain:true});\n        node.warn(`[seed] Creating humidity for ${r}: ${defaultHumidity}%`);\n        createdCount++;\n    }\n    \n    // Boost topics (initialize to 0)\n    if(!seen.boost || !seen.boost[r]){\n        out.push({topic:`virt/boost/${r}/minutes`, payload:'0', retain:true});\n        out.push({topic:`virt/boost/${r}/target_temp`, payload:'0', retain:true});\n        createdCount++;\n    }\n});\n\n// Weather (global, not per-room)\nif(!seen.weather){ out.push({topic:`virt/weather/current`, payload:JSON.stringify({ temp:20, description:'ƒçiastoƒçne oblaƒçno', icon:'02d', humidity:50, wind_speed:5, location:'Bratislava', country:'SK' }), retain:true}); }\nif(!seen.hourly){ const now=Date.now(); const hourly=Array.from({length:12}).map((_,i)=>({ dt: Math.floor((now/1000)+ (i+1)*3600), main:{temp: 20+Math.sin(i/3)*1.5}, weather:[{icon:'02d'}] })); out.push({topic:`virt/weather/hourly`, payload:JSON.stringify(hourly), retain:true}); }\n\n// Update seen state\nflow.set('seen', seen);\n\nif(removedRooms.length > 0 || createdCount > 0) {\n    node.warn(`[seed] Summary: removed ${removedRooms.length} rooms, created ${createdCount} new topics`);\n}\n\nreturn [out];",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 420,
    "y": 380,
    "wires": [
      [
        "mqtt_out"
      ]
    ]
  },
  {
    "id": "mqtt_out",
    "type": "mqtt out",
    "z": "tab_seed",
    "name": "seed out",
    "topic": "",
    "qos": "1",
    "retain": "true",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 640,
    "y": 380,
    "wires": []
  },
  {
    "id": "17d5dc83645deb1d",
    "type": "inject",
    "z": "tab_seed",
    "name": "",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": "1",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 110,
    "y": 60,
    "wires": [
      [
        "seen"
      ]
    ]
  },
  {
    "id": "ov_in",
    "type": "mqtt in",
    "z": "tab_override_expiry",
    "name": "virt/room/+/override (RH=1)",
    "topic": "virt/room/+/override",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 170,
    "y": 120,
    "wires": [
      [
        "ov_store"
      ]
    ]
  },
  {
    "id": "ov_store",
    "type": "function",
    "z": "tab_override_expiry",
    "name": "Store overrides",
    "func": "// Get valid rooms from config\nconst cfg = global.get('modesCfg');\nconst ROOMS = (cfg && Array.isArray(cfg.rooms)) ? cfg.rooms : [];\n\nconst room = (msg.topic||'').split('/')[2];\n\n// Skip if room is not in current config\nif (!ROOMS.includes(room)) {\n  return null; // Ignore override for non-existent rooms\n}\n\nlet data; try{ data = typeof msg.payload==='object'? msg.payload: JSON.parse(msg.payload);}catch(e){ data = msg.payload; }\n// Normalizuj na objekt\nconst ov = (data && typeof data === 'object') ? data : { active: (String(data).toLowerCase()!=='false' && data!==false) };\nconst map = flow.get('override_map') || {};\nmap[room] = ov;\nflow.set('override_map', map);\nreturn null;",
    "outputs": 0,
    "noerr": 0,
    "x": 430,
    "y": 120,
    "wires": []
  },
  {
    "id": "ov_cron",
    "type": "cronplus",
    "z": "tab_override_expiry",
    "name": "Every 1min + Startup",
    "outputField": "payload",
    "timeZone": "",
    "storeName": "",
    "commandResponseMsgOutput": "output1",
    "defaultLocation": "",
    "defaultLocationType": "default",
    "outputs": 1,
    "options": [
      {
        "name": "startup",
        "topic": "startup",
        "payloadType": "default",
        "payload": "",
        "expressionType": "cron",
        "expression": "0 * * * * *",
        "location": "",
        "offset": "0",
        "solarType": "all",
        "solarEvents": "sunrise,sunset"
      },
      {
        "name": "every_min",
        "topic": "every_min",
        "payloadType": "default",
        "payload": "",
        "expressionType": "cron",
        "expression": "0 */1 * * * *",
        "location": "",
        "offset": "0",
        "solarType": "all",
        "solarEvents": "sunrise,sunset"
      }
    ],
    "x": 160,
    "y": 200,
    "wires": [
      [
        "ov_check"
      ]
    ]
  },
  {
    "id": "ov_check",
    "type": "function",
    "z": "tab_override_expiry",
    "name": "Check expired & clear",
    "func": "// Get valid rooms from config\nconst cfg = global.get('modesCfg');\nconst ROOMS = (cfg && Array.isArray(cfg.rooms)) ? cfg.rooms : [];\n\nconst map = flow.get('override_map') || {};\nconst now = Date.now();\nconst out = [];\n\n// Process only rooms that exist in current config\nObject.keys(map).forEach(room => {\n  // Skip rooms not in current modes.yaml\n  if (!ROOMS.includes(room)) {\n    delete map[room]; // Clean up from cache\n    return;\n  }\n  \n  const ov = map[room];\n  if (!ov || ov.active === false) return;\n  if (!ov.until) return;\n  const until = Date.parse(ov.until);\n  if (!isFinite(until)) return;\n  if (now >= until) {\n    // Expired -> publish false and cleanup cache\n    out.push({ topic: `virt/room/${room}/override`, payload: 'false', retain: true });\n    map[room] = { active: false };\n  }\n});\nflow.set('override_map', map);\nreturn [out.length ? out : null];",
    "outputs": 1,
    "noerr": 0,
    "x": 410,
    "y": 200,
    "wires": [
      [
        "ov_out"
      ]
    ]
  },
  {
    "id": "ov_out",
    "type": "mqtt out",
    "z": "tab_override_expiry",
    "name": "virt/room/+/override=false",
    "topic": "",
    "qos": "1",
    "retain": "true",
    "broker": "mqtt_broker",
    "x": 680,
    "y": 200,
    "wires": []
  },
  {
    "id": "rd_seen_init",
    "type": "function",
    "z": "tab_retain_diag",
    "name": "Init seen mirror",
    "func": "flow.set('diag_seen', flow.get('diag_seen') || { targets:{}, enabled:{}, weather:false, hourly:false });\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 360,
    "y": 80,
    "wires": [
      []
    ]
  },
  {
    "id": "rd_in_target",
    "type": "mqtt in",
    "z": "tab_retain_diag",
    "name": "virt/room/+/target_temp (RH=1)",
    "topic": "virt/room/+/target_temp",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 200,
    "y": 140,
    "wires": [
      [
        "rd_mark_target"
      ]
    ]
  },
  {
    "id": "rd_mark_target",
    "type": "function",
    "z": "tab_retain_diag",
    "name": "mark target",
    "func": "const room=(msg.topic||'').split('/')[2];\nconst seen=flow.get('diag_seen')||{targets:{},enabled:{},weather:false,hourly:false};\nseen.targets[room]=true; flow.set('diag_seen',seen);\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 470,
    "y": 140,
    "wires": [
      []
    ]
  },
  {
    "id": "rd_in_enabled",
    "type": "mqtt in",
    "z": "tab_retain_diag",
    "name": "stat/hvac/+/enabled (RH=1)",
    "topic": "stat/hvac/+/enabled",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 200,
    "y": 200,
    "wires": [
      [
        "rd_mark_enabled"
      ]
    ]
  },
  {
    "id": "rd_mark_enabled",
    "type": "function",
    "z": "tab_retain_diag",
    "name": "mark enabled",
    "func": "const room=(msg.topic||'').split('/')[2];\nconst seen=flow.get('diag_seen')||{targets:{},enabled:{},weather:false,hourly:false};\nseen.enabled[room]=true; flow.set('diag_seen',seen);\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 470,
    "y": 200,
    "wires": [
      []
    ]
  },
  {
    "id": "rd_in_weather",
    "type": "mqtt in",
    "z": "tab_retain_diag",
    "name": "virt/weather/current (RH=1)",
    "topic": "virt/weather/current",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 200,
    "y": 260,
    "wires": [
      [
        "rd_mark_weather"
      ]
    ]
  },
  {
    "id": "rd_mark_weather",
    "type": "function",
    "z": "tab_retain_diag",
    "name": "mark weather",
    "func": "const seen=flow.get('diag_seen')||{targets:{},enabled:{},weather:false,hourly:false};\nseen.weather=true; flow.set('diag_seen',seen);\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 470,
    "y": 260,
    "wires": [
      []
    ]
  },
  {
    "id": "rd_in_hourly",
    "type": "mqtt in",
    "z": "tab_retain_diag",
    "name": "virt/weather/hourly (RH=1)",
    "topic": "virt/weather/hourly",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 210,
    "y": 320,
    "wires": [
      [
        "rd_mark_hourly"
      ]
    ]
  },
  {
    "id": "rd_mark_hourly",
    "type": "function",
    "z": "tab_retain_diag",
    "name": "mark hourly",
    "func": "const seen=flow.get('diag_seen')||{targets:{},enabled:{},weather:false,hourly:false};\nseen.hourly=true; flow.set('diag_seen',seen);\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "x": 470,
    "y": 320,
    "wires": [
      []
    ]
  },
  {
    "id": "rd_cron",
    "type": "inject",
    "z": "tab_retain_diag",
    "name": "Startup + every 10min",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "600",
    "crontab": "",
    "once": true,
    "onceDelay": "12",
    "topic": "",
    "payload": "{}",
    "payloadType": "json",
    "x": 190,
    "y": 400,
    "wires": [
      [
        "rd_report"
      ]
    ]
  },
  {
    "id": "rd_report",
    "type": "function",
    "z": "tab_retain_diag",
    "name": "Report missing retained",
    "func": "const cfg = global.get('modesCfg');\n// DEFAULT_ROOMS removed - use cfg.rooms instead\nconst ROOMS = (cfg && Array.isArray(cfg.rooms) && cfg.rooms.length) ? cfg.rooms : [];\nconst seen=flow.get('diag_seen')||{targets:{},enabled:{},weather:false,hourly:false};\nconst missingTargets=ROOMS.filter(r=>!seen.targets[r]);\nconst missingEnabled=ROOMS.filter(r=>!seen.enabled[r]);\nconst msgs=[];\nif(!seen.weather){ msgs.push('[retain-diag] Missing virt/weather/current'); }\nif(!seen.hourly){ msgs.push('[retain-diag] Missing virt/weather/hourly'); }\nif(missingTargets.length){ msgs.push('[retain-diag] Missing target_temp for: '+missingTargets.join(',')); }\nif(missingEnabled.length){ msgs.push('[retain-diag] Missing enabled for: '+missingEnabled.join(',')); }\nif(msgs.length){ msgs.forEach(m=>node.warn(m)); }\nreturn null;",
    "outputs": 0,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 470,
    "y": 400,
    "wires": []
  },
  {
    "id": "38f983f3a4efc68c",
    "type": "inject",
    "z": "tab_retain_diag",
    "name": "",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": "1",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 110,
    "y": 80,
    "wires": [
      [
        "rd_seen_init"
      ]
    ]
  },
  {
    "id": "ui_online_in",
    "type": "mqtt in",
    "z": "tab_ui_health",
    "name": "meta/service/ui/online",
    "topic": "meta/service/ui/online",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": false,
    "rh": 0,
    "inputs": 0,
    "x": 160,
    "y": 120,
    "wires": [
      [
        "ui_online_process"
      ]
    ]
  },
  {
    "id": "ui_online_process",
    "type": "function",
    "z": "tab_ui_health",
    "name": "Log & last_seen",
    "func": "const online = (msg.payload===true || String(msg.payload).toLowerCase()==='true' || msg.payload===1);\nnode.warn(`[ui] online = ${online}`);\nreturn [{ topic: 'meta/service/ui/last_seen', payload: new Date().toISOString(), retain: true }];",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 120,
    "wires": [
      [
        "ui_online_out"
      ]
    ]
  },
  {
    "id": "ui_online_out",
    "type": "mqtt out",
    "z": "tab_ui_health",
    "name": "last_seen",
    "topic": "",
    "qos": "0",
    "retain": "true",
    "broker": "mqtt_broker",
    "x": 590,
    "y": 120,
    "wires": []
  },
  {
    "id": "cbf25c776fe2ff17",
    "type": "cronplus",
    "z": "3c9175e0418cb802",
    "name": "Every 20s + Startup",
    "outputField": "payload",
    "timeZone": "",
    "storeName": "",
    "commandResponseMsgOutput": "output1",
    "defaultLocation": "",
    "defaultLocationType": "default",
    "outputs": 1,
    "options": [
      {
        "name": "startup",
        "topic": "startup",
        "payloadType": "default",
        "payload": "",
        "expressionType": "cron",
        "expression": "0 * * * * *",
        "location": "",
        "offset": "0",
        "solarType": "all",
        "solarEvents": "sunrise,sunset"
      },
      {
        "name": "poll",
        "topic": "poll",
        "payloadType": "default",
        "payload": "",
        "expressionType": "cron",
        "expression": "*/20 * * * * *",
        "location": "",
        "offset": "0",
        "solarType": "all",
        "solarEvents": "sunrise,sunset"
      }
    ],
    "x": 160,
    "y": 100,
    "wires": [
      [
        "20bfe6f925bf6e48"
      ]
    ]
  },
  {
    "id": "20bfe6f925bf6e48",
    "type": "function",
    "z": "3c9175e0418cb802",
    "name": "Prepare CalDAV Request",
    "func": "const baseUrl = env.get('BAIKAL_BASE_URL');\nconst user = env.get('BAIKAL_USER');\nconst pass = env.get('BAIKAL_PASS');\nconst calId = env.get('BAIKAL_CAL_ID');\nif (!baseUrl) { node.error('[calendar] BAIKAL_BASE_URL not set'); return null; }\nconst url = `${baseUrl}/calendars/${user}/${calId}/`;\nconst auth = Buffer.from(`${user}:${pass}`).toString('base64');\nconst now = new Date();\nconst start = new Date(now.getTime() - 86400000);\nconst end = new Date(now.getTime() + 7*86400000);\nconst formatDate = d => d.toISOString().replace(/[-:]/g,'').split('.')[0] + 'Z';\nconst xmlBody = `<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<c:calendar-query xmlns:d=\"DAV:\" xmlns:c=\"urn:ietf:params:xml:ns:caldav\">\n <d:prop><c:calendar-data/></d:prop>\n <c:filter><c:comp-filter name=\"VCALENDAR\"><c:comp-filter name=\"VEVENT\"><c:time-range start=\"${formatDate(start)}\" end=\"${formatDate(end)}\"/></c:comp-filter></c:comp-filter></c:filter>\n</c:calendar-query>`;\nmsg.url = url; msg.method='REPORT'; msg.headers={Authorization:`Basic ${auth}`,'Content-Type':'application/xml; charset=utf-8','Depth':'1'}; msg.payload=xmlBody; node.warn(`[calendar] CalDAV REPORT ${url}`); return msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 230,
    "y": 220,
    "wires": [
      [
        "0e62ca064ee3a871"
      ]
    ]
  },
  {
    "id": "0e62ca064ee3a871",
    "type": "http request",
    "z": "3c9175e0418cb802",
    "name": "HTTP REPORT",
    "method": "use",
    "ret": "txt",
    "paytoqs": "ignore",
    "url": "",
    "persist": false,
    "x": 420,
    "y": 100,
    "wires": [
      [
        "e1940333e078a33c"
      ]
    ]
  },
  {
    "id": "e1940333e078a33c",
    "type": "function",
    "z": "3c9175e0418cb802",
    "name": "Parse XML Response",
    "func": "const xml = msg.payload; const events=[]; const re=/<(?:c|cal):calendar-data>([\\s\\S]*?)<\\/(?:c|cal):calendar-data>/gi; let m; while((m=re.exec(xml))!==null){ const ical=m[1].trim(); const uid=/(?:^|\\n)UID:([^\\r\\n]+)/.exec(ical); const sum=/(?:^|\\n)SUMMARY:([^\\r\\n]+)/.exec(ical); const desc=/(?:^|\\n)DESCRIPTION:([^\\r\\n]+)/.exec(ical); const st=/(?:^|\\n)DTSTART:([^\\r\\n]+)/.exec(ical); const en=/(?:^|\\n)DTEND:([^\\r\\n]+)/.exec(ical); if(uid&&sum&&st&&en){ const parseDate = s => new Date(`${s.substr(0,4)}-${s.substr(4,2)}-${s.substr(6,2)}T${s.substr(9,2)}:${s.substr(11,2)}:${s.substr(13,2)}Z`); events.push({ uid: uid[1], summary: sum[1], description: desc?desc[1]:'', start: parseDate(st[1]), end: parseDate(en[1])}); } } node.warn(`[calendar] Parsed ${events.length} events`); msg.payload=events; return msg;",
    "outputs": 1,
    "x": 540,
    "y": 220,
    "wires": [
      [
        "a1be2b03fde9264a"
      ]
    ]
  },
  {
    "id": "a1be2b03fde9264a",
    "type": "function",
    "z": "3c9175e0418cb802",
    "name": "Parse DSL & Store Events",
    "func": "/* Baikal events parse; preserve existing Google events in merged calendarEvents */\nconst now=new Date();\nconst raw=msg.payload||[];\nconst baikalEvents=[];\nfor(const e of raw){\n  const sum=e.summary||'';\n  const desc=e.description||'';\n  const start=new Date(e.start);\n  const end=new Date(e.end);\n  const active= now>=start && now<=end;\n  const parsed={ uid:e.uid, summary:sum, description:desc, start:start.toISOString(), end:end.toISOString(), active, type:null, params:{}, source:'baikal' };\n  const mode=sum.match(/SMH\\s+MODE\\s*=\\s*(\\w+)/i); if(mode){ parsed.type='mode'; parsed.params.mode=mode[1].toLowerCase(); node.warn(`[calendar] MODE event: ${sum}, active=${active}, mode=${parsed.params.mode}, start=${start.toISOString()}, end=${end.toISOString()}, now=${now.toISOString()}`); }\n  const boost=sum.match(/SMH\\s+BOOST\\s+room\\s*=\\s*(\\w+)(?:\\s+temp\\s*=\\s*([\\d.]+))?(?:\\s+dur\\s*=\\s*(\\d+))?/i); if(boost){ parsed.type='boost'; parsed.params.room=boost[1].toLowerCase(); parsed.params.temp=boost[2]?parseFloat(boost[2]):null; parsed.params.duration=boost[3]?parseInt(boost[3]):60; }\n  const offset=sum.match(/SMH\\s+OFFSET\\s+room\\s*=\\s*(\\w+)\\s+([+-][\\d.]+)(?:\\s+dur\\s*=\\s*(\\d+))?/i); if(offset){ parsed.type='offset'; parsed.params.room=offset[1].toLowerCase(); parsed.params.offset=parseFloat(offset[2]); parsed.params.duration=offset[3]?parseInt(offset[3]):null; }\n  if(!parsed.type){ parsed.type='calendar'; parsed.params.eventName=sum; }\n  baikalEvents.push(parsed);\n}\nconst prev=global.get('calendarEvents')||[];\nconst prevGoogle=prev.filter(e=>e.source==='google');\nconst prevBaikalActive=prev.filter(e=>e.source!=='google' && e.active).map(e=>e.uid);\nconst newly=baikalEvents.filter(e=>e.active && !prevBaikalActive.includes(e.uid));\nif(newly.length){ newly.forEach(x=>node.warn(`[calendar] Late-add ${x.type}`)); }\nconst combined=baikalEvents.concat(prevGoogle);\nglobal.set('calendarEvents', combined);\nmsg.payload={ total:combined.length, active:combined.filter(x=>x.active).length, newlyActive:newly, events:combined, sourceCounts:{ baikal: baikalEvents.length, google: prevGoogle.length }, timestamp: now.toISOString() };\nreturn msg;",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 700,
    "y": 100,
    "wires": [
      [
        "e224bf2d80511330",
        "1238cfd23e135f85"
      ]
    ]
  },
  {
    "id": "e224bf2d80511330",
    "type": "mqtt out",
    "z": "3c9175e0418cb802",
    "name": "Calendar Events",
    "topic": "virt/calendar/events/current",
    "qos": "1",
    "retain": "true",
    "broker": "mqtt_broker",
    "x": 850,
    "y": 220,
    "wires": []
  },
  {
    "id": "1238cfd23e135f85",
    "type": "function",
    "z": "3c9175e0418cb802",
    "name": "Apply Late-Add Events",
    "func": "const newly=msg.payload.newlyActive||[]; if(!newly.length) return null; const msgs=[]; for(const e of newly){ if(e.type==='boost'&&e.params.room){ node.warn(`[late-add] BOOST: room=${e.params.room}, temp=${e.params.temp}, dur=${e.params.duration||60}`); msgs.push({topic:`virt/boost/${e.params.room}/minutes`,payload:e.params.duration||60,retain:true}); node.warn(`[late-add] After minutes push: msgs.length=${msgs.length}`); if(e.params.temp){ msgs.push({topic:`virt/boost/${e.params.room}/target_temp`,payload:e.params.temp,retain:true}); node.warn(`[late-add] After temp push: msgs.length=${msgs.length}`); } } if(e.type==='offset'&&e.params.room){ msgs.push({topic:`virt/offset/${e.params.room}/value`,payload:e.params.offset,retain:true}); } if(e.type==='mode'){ msgs.push({topic:'internal/recalc_mode',payload:{trigger:'calendar',mode:e.params.mode}}); } } node.warn(`[late-add] Returning ${msgs.length} messages`); msg.payload=msgs; return msg;",
    "outputs": 1,
    "x": 220,
    "y": 340,
    "wires": [
      [
        "baikal_late_split"
      ]
    ]
  },
  {
    "id": "baikal_late_split",
    "type": "split",
    "z": "3c9175e0418cb802",
    "name": "Split Messages",
    "splt": "\\n",
    "spltType": "str",
    "arraySplt": 1,
    "arraySpltType": "len",
    "stream": false,
    "addname": "",
    "x": 350,
    "y": 340,
    "wires": [
      [
        "22eed87c09bb0b81"
      ]
    ]
  },
  {
    "id": "22eed87c09bb0b81",
    "type": "mqtt out",
    "z": "3c9175e0418cb802",
    "name": "",
    "topic": "",
    "qos": "",
    "retain": "",
    "broker": "mqtt_broker",
    "x": 470,
    "y": 340,
    "wires": []
  },
  {
    "id": "4304a79604698e2b",
    "type": "mqtt in",
    "z": "33bedd3c7b4b855f",
    "name": "virt/room/+/override_request",
    "topic": "virt/room/+/override_request",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 200,
    "y": 160,
    "wires": [
      [
        "6d508d130b641763"
      ]
    ]
  },
  {
    "id": "6d508d130b641763",
    "type": "function",
    "z": "33bedd3c7b4b855f",
    "name": "request -> cmd",
    "func": "const room=(msg.topic||'').split('/')[2]; let data; try{ data= typeof msg.payload==='object'? msg.payload: JSON.parse(msg.payload);}catch(e){ data={}; } const minutes=Number((data.durationMinutes??data.minutes??data.duration??60)); const until=new Date(Date.now()+minutes*60000).toISOString(); const payload={active:data.active!==false,value:Number(data.value)||21,durationMinutes:minutes,until}; return { topic:`cmd/hvac/${room}/override`, payload: JSON.stringify(payload)};",
    "outputs": 1,
    "x": 450,
    "y": 160,
    "wires": [
      [
        "b0862b5673a41850"
      ]
    ]
  },
  {
    "id": "b0862b5673a41850",
    "type": "function",
    "z": "33bedd3c7b4b855f",
    "name": "cmd -> virt/override",
    "func": "const room=(msg.topic||'').split('/')[2]; let data; try{ data= typeof msg.payload==='object'? msg.payload: JSON.parse(msg.payload);}catch(e){ data={}; } if(data.active===false){ return { topic:`virt/room/${room}/override`, payload:'false', retain:true }; } const out={ active:true, value:Number(data.value)||21, until:data.until }; return { topic:`virt/room/${room}/override`, payload: JSON.stringify(out), retain:true };",
    "outputs": 1,
    "x": 470,
    "y": 100,
    "wires": [
      [
        "cc8d9c905eb4eed7"
      ]
    ]
  },
  {
    "id": "cc8d9c905eb4eed7",
    "type": "mqtt out",
    "z": "33bedd3c7b4b855f",
    "name": "virt/room/+/override",
    "topic": "",
    "qos": "1",
    "retain": "true",
    "broker": "mqtt_broker",
    "x": 740,
    "y": 120,
    "wires": []
  },
  {
    "id": "gcal_cron",
    "type": "cronplus",
    "z": "tab_calendar_google",
    "name": "Every 60s + Startup",
    "outputField": "payload",
    "timeZone": "",
    "storeName": "",
    "commandResponseMsgOutput": "output1",
    "defaultLocation": "",
    "defaultLocationType": "default",
    "outputs": 1,
    "options": [
      {
        "name": "startup",
        "topic": "startup",
        "payloadType": "default",
        "payload": "",
        "expressionType": "cron",
        "expression": "0 * * * * *",
        "location": "",
        "offset": "0",
        "solarType": "all",
        "solarEvents": "sunrise,sunset"
      },
      {
        "name": "poll",
        "topic": "poll",
        "payloadType": "default",
        "payload": "",
        "expressionType": "cron",
        "expression": "*/60 * * * * *",
        "location": "",
        "offset": "0",
        "solarType": "all",
        "solarEvents": "sunrise,sunset"
      }
    ],
    "x": 160,
    "y": 100,
    "wires": [
      [
        "gcal_prepare"
      ]
    ]
  },
  {
    "id": "gcal_prepare",
    "type": "function",
    "z": "tab_calendar_google",
    "name": "Prepare Google Request",
    "func": "const apiKey = env.get('GOOGLE_CALENDAR_API_KEY');\nconst calId = env.get('GOOGLE_CALENDAR_ID');\nif(!apiKey || !calId){ node.warn('[gcal] Missing GOOGLE_CALENDAR_API_KEY or GOOGLE_CALENDAR_ID'); return null;}\nconst now = new Date();\nconst start = new Date(now.getTime() - 86400000);\nconst end = new Date(now.getTime() + 7*86400000);\nconst toRFC3339 = d => d.toISOString();\nconst baseUrl = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calId)}/events`;\nconst params = `?key=${apiKey}&singleEvents=true&orderBy=startTime&timeMin=${encodeURIComponent(toRFC3339(start))}&timeMax=${encodeURIComponent(toRFC3339(end))}`;\nmsg.url = baseUrl + params;\nmsg.method='GET';\nnode.warn(`[gcal] GET ${msg.url}`);\nreturn msg;",
    "outputs": 1,
    "x": 360,
    "y": 100,
    "wires": [
      [
        "gcal_http"
      ]
    ]
  },
  {
    "id": "gcal_http",
    "type": "http request",
    "z": "tab_calendar_google",
    "name": "HTTP GET",
    "method": "use",
    "ret": "obj",
    "paytoqs": "ignore",
    "url": "",
    "persist": false,
    "x": 560,
    "y": 100,
    "wires": [
      [
        "gcal_parse"
      ]
    ]
  },
  {
    "id": "gcal_parse",
    "type": "function",
    "z": "tab_calendar_google",
    "name": "Parse & Merge Events",
    "func": "const items = msg.payload?.items || [];\nconst now=new Date();\nconst parsed=[];\nfor(const it of items){\n  const summary=it.summary||'';\n  const description=it.description||'';\n  const startStr=it.start?.dateTime || (it.start?.date ? it.start.date+'T00:00:00Z': null);\n  const endStr=it.end?.dateTime || (it.end?.date ? it.end.date+'T23:59:59Z': null);\n  if(!startStr || !endStr) continue;\n  const start=new Date(startStr);\n  const end=new Date(endStr);\n  const active= now>=start && now<=end;\n  const ev={ uid:`gcal-${it.id}`, summary, description, start:start.toISOString(), end:end.toISOString(), active, type:null, params:{}, source:'google' };\n  const mode=summary.match(/SMH\\s+MODE\\s*=\\s*(\\w+)/i); if(mode){ ev.type='mode'; ev.params.mode=mode[1].toLowerCase(); }\n  const boost=summary.match(/SMH\\s+BOOST\\s+room\\s*=\\s*(\\w+)(?:\\s+temp\\s*=\\s*([\\d.]+))?(?:\\s+dur\\s*=\\s*(\\d+))?/i); if(boost){ ev.type='boost'; ev.params.room=boost[1].toLowerCase(); ev.params.temp=boost[2]?parseFloat(boost[2]):null; ev.params.duration=boost[3]?parseInt(boost[3]):60; }\n  const offset=summary.match(/SMH\\s+OFFSET\\s+room\\s*=\\s*(\\w+)\\s+([+-][\\d.]+)(?:\\s+dur\\s*=\\s*(\\d+))?/i); if(offset){ ev.type='offset'; ev.params.room=offset[1].toLowerCase(); ev.params.offset=parseFloat(offset[2]); ev.params.duration=offset[3]?parseInt(offset[3]):null; }\n  if(!ev.type){ ev.type='calendar'; ev.params.eventName=summary; }\n  parsed.push(ev);\n}\nconst prev=global.get('calendarEvents')||[];\nconst prevGoogleActive=prev.filter(e=>e.source==='google' && e.active).map(e=>e.uid);\nconst nonGoogle=prev.filter(e=>e.source!=='google');\nconst newly=parsed.filter(e=>e.active && !prevGoogleActive.includes(e.uid));\nif(newly.length){ newly.forEach(e=>node.warn(`[gcal] Late-add ${e.type}`)); }\nconst combined = nonGoogle.concat(parsed);\nglobal.set('calendarEvents', combined);\nmsg.payload={ total:combined.length, active:combined.filter(e=>e.active).length, events:combined, newlyActive:newly, sourceCounts:{ google: parsed.length, baikal: nonGoogle.length }, timestamp: now.toISOString() };\nreturn msg;",
    "outputs": 1,
    "x": 770,
    "y": 100,
    "wires": [
      [
        "gcal_mqtt",
        "gcal_late_add"
      ]
    ]
  },
  {
    "id": "gcal_mqtt",
    "type": "mqtt out",
    "z": "tab_calendar_google",
    "name": "Calendar Events (merged)",
    "topic": "virt/calendar/events/current",
    "qos": "1",
    "retain": "true",
    "broker": "mqtt_broker",
    "x": 1010,
    "y": 120,
    "wires": []
  },
  {
    "id": "gcal_late_add",
    "type": "function",
    "z": "tab_calendar_google",
    "name": "Apply Late-Add (Google)",
    "func": "const newly=msg.payload.newlyActive||[]; if(!newly.length) return null; const msgs=[]; for(const e of newly){ if(e.type==='boost'&&e.params.room){ node.warn(`[late-add-gcal] BOOST: room=${e.params.room}, temp=${e.params.temp}, dur=${e.params.duration||60}`); msgs.push({topic:`virt/boost/${e.params.room}/minutes`,payload:e.params.duration||60,retain:true}); node.warn(`[late-add-gcal] After minutes push: msgs.length=${msgs.length}`); if(e.params.temp){ msgs.push({topic:`virt/boost/${e.params.room}/target_temp`,payload:e.params.temp,retain:true}); node.warn(`[late-add-gcal] After temp push: msgs.length=${msgs.length}`); } } if(e.type==='offset'&&e.params.room){ msgs.push({topic:`virt/offset/${e.params.room}/value`,payload:e.params.offset,retain:true}); } if(e.type==='mode'){ msgs.push({topic:'internal/recalc_mode',payload:{trigger:'calendar',mode:e.params.mode}}); } } node.warn(`[late-add-gcal] Returning ${msgs.length} messages`); msg.payload=msgs; return msg;",
    "outputs": 1,
    "x": 250,
    "y": 240,
    "wires": [
      [
        "gcal_late_split"
      ]
    ]
  },
  {
    "id": "gcal_late_split",
    "type": "split",
    "z": "tab_calendar_google",
    "name": "Split Messages",
    "splt": "\\n",
    "spltType": "str",
    "arraySplt": 1,
    "arraySpltType": "len",
    "stream": false,
    "addname": "",
    "x": 470,
    "y": 240,
    "wires": [
      [
        "gcal_late_add_out"
      ]
    ]
  },
  {
    "id": "gcal_late_add_out",
    "type": "mqtt out",
    "z": "tab_calendar_google",
    "name": "Late-Add MQTT",
    "topic": "",
    "qos": "",
    "retain": "",
    "broker": "mqtt_broker",
    "x": 520,
    "y": 240,
    "wires": []
  },
  {
    "id": "boost_minutes_in",
    "type": "mqtt in",
    "z": "tab_boost",
    "name": "virt/boost/+/minutes",
    "topic": "virt/boost/+/minutes",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 150,
    "y": 100,
    "wires": [
      [
        "boost_store_minutes"
      ]
    ]
  },
  {
    "id": "boost_store_minutes",
    "type": "function",
    "z": "tab_boost",
    "name": "Store Boost Minutes",
    "func": "const room = (msg.topic || '').split('/')[2];\nconst minutes = parseInt(msg.payload);\n\nif (isNaN(minutes)) {\n    node.warn(`[boost] Invalid minutes value for ${room}: ${msg.payload}`);\n    return null;\n}\n\nglobal.set(`boost_${room}_minutes`, minutes);\nglobal.set(`boost_${room}_active`, minutes > 0);\n\nnode.log(`[boost] ${room}: minutes=${minutes}, active=${minutes > 0}`);\n\nreturn null;",
    "outputs": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 100,
    "wires": []
  },
  {
    "id": "boost_temp_in",
    "type": "mqtt in",
    "z": "tab_boost",
    "name": "virt/boost/+/target_temp",
    "topic": "virt/boost/+/target_temp",
    "qos": "1",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 1,
    "inputs": 0,
    "x": 160,
    "y": 160,
    "wires": [
      [
        "boost_store_temp"
      ]
    ]
  },
  {
    "id": "boost_store_temp",
    "type": "function",
    "z": "tab_boost",
    "name": "Store Boost Target Temp",
    "func": "const room = (msg.topic || '').split('/')[2];\nconst temp = parseFloat(msg.payload);\n\nif (isNaN(temp)) {\n    node.warn(`[boost] Invalid temp value for ${room}: ${msg.payload}`);\n    return null;\n}\n\nglobal.set(`boost_${room}_target_temp`, temp);\n\nnode.log(`[boost] ${room}: target_temp=${temp}¬∞C`);\n\nreturn null;",
    "outputs": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 400,
    "y": 160,
    "wires": []
  },
  {
    "id": "boost_cron",
    "type": "cronplus",
    "z": "tab_boost",
    "name": "Every 60s",
    "outputField": "payload",
    "timeZone": "",
    "storeName": "",
    "commandResponseMsgOutput": "output1",
    "defaultLocation": "",
    "defaultLocationType": "default",
    "outputs": 1,
    "options": [
      {
        "name": "countdown",
        "topic": "countdown",
        "payloadType": "default",
        "payload": "",
        "expressionType": "cron",
        "expression": "0 */1 * * * *",
        "location": "",
        "offset": "0",
        "solarType": "all",
        "solarEvents": "sunrise,sunset"
      }
    ],
    "x": 150,
    "y": 260,
    "wires": [
      [
        "boost_countdown"
      ]
    ]
  },
  {
    "id": "boost_countdown",
    "type": "function",
    "z": "tab_boost",
    "name": "Decrement Boost Timers",
    "func": "const cfg = global.get('modesCfg');\n// DEFAULT_ROOMS removed - use cfg.rooms instead\nconst ROOMS = (cfg && Array.isArray(cfg.rooms) && cfg.rooms.length) ? cfg.rooms : [];\n\nconst messages = [];\nlet anyChanged = false;\n\nROOMS.forEach(room => {\n    const minutes = global.get(`boost_${room}_minutes`);\n    \n    if (minutes === null || minutes === undefined || minutes <= 0) {\n        return;\n    }\n    \n    const newMinutes = minutes - 1;\n    \n    global.set(`boost_${room}_minutes`, newMinutes);\n    \n    if (newMinutes > 0) {\n        // Still active, publish decremented value\n        messages.push({\n            topic: `virt/boost/${room}/minutes`,\n            payload: newMinutes,\n            retain: true\n        });\n        \n        global.set(`boost_${room}_active`, true);\n        \n        node.warn(`[boost] ${room}: countdown ${newMinutes} minutes remaining`);\n        anyChanged = true;\n        \n    } else {\n        // Timer expired, clear boost\n        messages.push({\n            topic: `virt/boost/${room}/minutes`,\n            payload: 0,\n            retain: true\n        });\n        \n        messages.push({\n            topic: `virt/boost/${room}/target_temp`,\n            payload: 0,\n            retain: true\n        });\n        \n        global.set(`boost_${room}_active`, false);\n        global.set(`boost_${room}_target_temp`, null);\n        \n        node.warn(`[boost] ${room}: EXPIRED, clearing boost`);\n        anyChanged = true;\n    }\n});\n\nif (anyChanged) {\n    // Trigger planner recalculation\n    messages.push({\n        topic: 'internal/planner/orchestrate',\n        payload: { trigger: 'boost_change' }\n    });\n}\n\nif (messages.length > 0) {\n    return [messages];\n}\n\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 380,
    "y": 260,
    "wires": [
      [
        "boost_mqtt_out"
      ]
    ]
  },
  {
    "id": "boost_mqtt_out",
    "type": "mqtt out",
    "z": "tab_boost",
    "name": "Boost Updates",
    "topic": "",
    "qos": "1",
    "retain": "",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 620,
    "y": 260,
    "wires": []
  },
  {
    "id": "init_defaults_inject",
    "type": "inject",
    "z": "tab_init_defaults",
    "name": "Startup (5s delay)",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": true,
    "onceDelay": "5",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 150,
    "y": 60,
    "wires": [
      [
        "init_defaults_function"
      ]
    ]
  },
  {
    "id": "init_defaults_function",
    "type": "function",
    "z": "tab_init_defaults",
    "name": "Publish Default Target Temps",
    "func": "const cfg = global.get('modesCfg');\n// DEFAULT_ROOMS removed - use cfg.rooms instead\nconst ROOMS = (cfg && Array.isArray(cfg.rooms) && cfg.rooms.length) ? cfg.rooms : [];\nconst DEFAULT_TEMP = 21;\n\nconst messages = [];\n\nROOMS.forEach(room => {\n    // Publish default target temp (retained)\n    // Planner will override this with scheduled values\n    messages.push({\n        topic: `virt/room/${room}/target_temp`,\n        payload: DEFAULT_TEMP,\n        retain: true\n    });\n    \n    node.warn(`[init] Publishing default target temp for ${room}: ${DEFAULT_TEMP}¬∞C`);\n});\n\nreturn [messages];",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 420,
    "y": 60,
    "wires": [
      [
        "init_defaults_mqtt_out"
      ]
    ]
  },
  {
    "id": "init_defaults_mqtt_out",
    "type": "mqtt out",
    "z": "tab_init_defaults",
    "name": "Publish Defaults",
    "topic": "",
    "qos": "1",
    "retain": "",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 680,
    "y": 60,
    "wires": []
  },
  {
    "id": "mqtt_temp_in",
    "type": "mqtt in",
    "z": "influx_test_flow",
    "name": "Teploty MQTT",
    "topic": "stat/hvac/+/current_temp",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 130,
    "y": 80,
    "wires": [
      [
        "format_temp"
      ]
    ]
  },
  {
    "id": "format_temp",
    "type": "function",
    "z": "influx_test_flow",
    "name": "Format for InfluxDB",
    "func": "const room = msg.topic.split('/')[2];\nconst temp = parseFloat(msg.payload);\n\nif (isNaN(temp)) return null;\n\n// n√°zov measurementu\nmsg.measurement = \"temperature\";\n\n// 1. objekt = FIELDS, 2. objekt = TAGS\nmsg.payload = [\n  {\n    value: temp        // ƒç√≠seln√° hodnota -> field \"value\"\n  },\n  {\n    room: room,        // tag \"room\"\n    sensor: \"hvac\"     // tag \"sensor\"\n  }\n];\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 350,
    "y": 80,
    "wires": [
      [
        "debug_temp",
        "91ed2c546c02f2ce"
      ]
    ]
  },
  {
    "id": "debug_temp",
    "type": "debug",
    "z": "influx_test_flow",
    "name": "Debug",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "true",
    "targetType": "full",
    "statusVal": "",
    "statusType": "auto",
    "x": 560,
    "y": 40,
    "wires": []
  },
  {
    "id": "mqtt_humidity_in",
    "type": "mqtt in",
    "z": "influx_test_flow",
    "name": "Vlhkos≈• MQTT",
    "topic": "stat/hvac/+/humidity",
    "qos": "0",
    "datatype": "auto",
    "broker": "mqtt_broker",
    "nl": false,
    "rap": true,
    "rh": 0,
    "inputs": 0,
    "x": 130,
    "y": 180,
    "wires": [
      [
        "format_humidity"
      ]
    ]
  },
  {
    "id": "format_humidity",
    "type": "function",
    "z": "influx_test_flow",
    "name": "Format for InfluxDB",
    "func": "const room = msg.topic.split('/')[2];\nconst humidity = parseFloat(msg.payload);\n\nif (isNaN(humidity)) return null;\n\n// n√°zov measurementu\nmsg.measurement = \"humidity\";\n\n// 1. objekt = FIELDS, 2. objekt = TAGS\nmsg.payload = [\n    {\n        value: humidity        // ƒç√≠seln√° hodnota -> field \"value\"\n    },\n    {\n        room: room,        // tag \"room\"\n        sensor: \"hvac\"     // tag \"sensor\"\n    }\n];\nreturn msg;",
    "outputs": 1,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 350,
    "y": 180,
    "wires": [
      [
        "debug_humidity",
        "aa3c147c4a6f9cbd"
      ]
    ]
  },
  {
    "id": "debug_humidity",
    "type": "debug",
    "z": "influx_test_flow",
    "name": "Debug",
    "active": true,
    "tosidebar": true,
    "console": false,
    "tostatus": false,
    "complete": "payload",
    "targetType": "msg",
    "statusVal": "",
    "statusType": "auto",
    "x": 560,
    "y": 140,
    "wires": []
  },
  {
    "id": "inject_test",
    "type": "inject",
    "z": "influx_test_flow",
    "name": "Test inject",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "stat/hvac/spalna/current_temp",
    "payload": "21.5",
    "payloadType": "num",
    "x": 130,
    "y": 280,
    "wires": [
      [
        "format_temp"
      ]
    ]
  },
  {
    "id": "91ed2c546c02f2ce",
    "type": "influxdb out",
    "z": "influx_test_flow",
    "influxdb": "81faacfd71aafa3e",
    "name": "",
    "measurement": "",
    "precision": "",
    "retentionPolicy": "",
    "database": "database",
    "precisionV18FluxV20": "ms",
    "retentionPolicyV18Flux": "",
    "org": "Home",
    "bucket": "smarthome",
    "x": 600,
    "y": 80,
    "wires": []
  },
  {
    "id": "aa3c147c4a6f9cbd",
    "type": "influxdb out",
    "z": "influx_test_flow",
    "influxdb": "81faacfd71aafa3e",
    "name": "",
    "measurement": "humidity",
    "precision": "",
    "retentionPolicy": "",
    "database": "database",
    "precisionV18FluxV20": "ms",
    "retentionPolicyV18Flux": "",
    "org": "Home",
    "bucket": "smarthome",
    "x": 630,
    "y": 180,
    "wires": []
  },
  {
    "id": "223d415771b6d2c7",
    "type": "inject",
    "z": "influx_test_flow",
    "name": "Test inject",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "stat/hvac/detska/humidity",
    "payload": "60",
    "payloadType": "num",
    "x": 140,
    "y": 340,
    "wires": [
      [
        "format_humidity"
      ]
    ]
  },
  {
    "id": "tab_watcher",
    "type": "tab",
    "label": "Config Watcher",
    "disabled": false,
    "info": "Sleduje zmeny v modes.yaml a triggeruje reload"
  },
  {
    "id": "watcher_inject",
    "type": "inject",
    "z": "tab_watcher",
    "name": "Check every 30s",
    "props": [
      {
        "p": "payload"
      }
    ],
    "repeat": "30",
    "crontab": "",
    "once": true,
    "onceDelay": "10",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 140,
    "y": 100,
    "wires": [
      [
        "watcher_check"
      ]
    ]
  },
  {
    "id": "watcher_check",
    "type": "function",
    "z": "tab_watcher",
    "name": "Check mtime",
    "func": "// File watcher for modes.yaml - triggers reload on config change\nconst fs = require('fs');\nconst path = '/config/modes.yaml';\n\n// Store last modified time in context\nlet lastMtime = context.get('lastMtime') || null;\n\n// Check file modification time\ntry {\n    const stats = fs.statSync(path);\n    const currentMtime = stats.mtime.getTime();\n    \n    if (lastMtime === null) {\n        // First run - just store the time\n        context.set('lastMtime', currentMtime);\n        node.status({fill: 'green', shape: 'dot', text: 'watching'});\n        return null;\n    }\n    \n    if (currentMtime > lastMtime) {\n        // File was modified - trigger reload\n        context.set('lastMtime', currentMtime);\n        node.status({fill: 'yellow', shape: 'ring', text: 'change detected'});\n        node.warn(`modes.yaml changed, triggering reload (mtime: ${new Date(currentMtime).toISOString()})`);\n        return msg;\n    }\n    \n    // No change\n    node.status({fill: 'green', shape: 'dot', text: 'watching'});\n    return null;\n    \n} catch (err) {\n    node.error(`Failed to check modes.yaml: ${err.message}`);\n    node.status({fill: 'red', shape: 'ring', text: 'error'});\n    return null;\n}",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 340,
    "y": 100,
    "wires": [
      [
        "watcher_reload",
        "watcher_mqtt_notify"
      ]
    ]
  },
  {
    "id": "watcher_reload",
    "type": "link out",
    "z": "tab_watcher",
    "name": "Trigger Loader",
    "mode": "link",
    "links": [
      "loader_schema_in"
    ],
    "x": 535,
    "y": 100,
    "wires": []
  },
  {
    "id": "watcher_mqtt_notify",
    "type": "function",
    "z": "tab_watcher",
    "name": "Prepare MQTT Event",
    "func": "// Publish config_updated event to notify UI\nmsg.topic = 'virt/system/config_updated';\nmsg.payload = JSON.stringify({\n    timestamp: new Date().toISOString(),\n    source: 'modes.yaml',\n    action: 'reload'\n});\nmsg.retain = false;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 360,
    "y": 160,
    "wires": [
      [
        "watcher_mqtt_out"
      ]
    ]
  },
  {
    "id": "watcher_mqtt_out",
    "type": "mqtt out",
    "z": "tab_watcher",
    "name": "Publish config_updated",
    "topic": "",
    "qos": "0",
    "retain": "false",
    "respTopic": "",
    "contentType": "",
    "userProps": "",
    "correl": "",
    "expiry": "",
    "broker": "mqtt_broker",
    "x": 590,
    "y": 160,
    "wires": []
  }
]
